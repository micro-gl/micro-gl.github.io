<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/467cda79f80b7119.css" as="style"/><link rel="stylesheet" href="/_next/static/css/467cda79f80b7119.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-7477d36a73a3487c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8050cb959e6fa9ab.js" defer=""></script><script src="/_next/static/chunks/d7eeaac4-dbfd17fa893b1a6b.js" defer=""></script><script src="/_next/static/chunks/d64684d8-af995873706b0ebb.js" defer=""></script><script src="/_next/static/chunks/949-00a18eddf445c2d2.js" defer=""></script><script src="/_next/static/chunks/269-e752981b20d98295.js" defer=""></script><script src="/_next/static/chunks/pages/docs/micro-tess/%5B%5B...slug%5D%5D-9e6f12ff5cdb2e1f.js" defer=""></script><script src="/_next/static/dV491GG50l9Rddb8EbHVQ/_buildManifest.js" defer=""></script><script src="/_next/static/dV491GG50l9Rddb8EbHVQ/_ssgManifest.js" defer=""></script></head><body class="w-screen h-screen"><div id="__next"></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"logo":"/logos/microtess-512-logo.png","slug":"concepts/triangles","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    strong: \"strong\",\n    code: \"code\",\n    ol: \"ol\",\n    li: \"li\",\n    h2: \"h2\",\n    blockquote: \"blockquote\",\n    br: \"br\",\n    ul: \"ul\",\n    h3: \"h3\",\n    h4: \"h4\",\n    pre: \"pre\"\n  }, _provideComponents(), props.components), {Image} = _components;\n  if (!Image) _missingMdxReference(\"Image\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Introduction\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"All algorithms in \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"micro{tess}\"\n        })\n      }), \" have two types of output:\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Triangles tessellation\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Arc dividing\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Triangles\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Look at \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"\u003cmicrotess/triangles.h\u003e\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Triangulation is essentially just a set of triangles, that can be happily rendered using well\\nknown rasterization algorithms, they are used everywhere because of it.\", _jsx(_components.br, {}), \"\\n\", \"In order to define a single triangle, we just need three points, but in order to define a\", _jsx(_components.br, {}), \"\\n\", \"batch of triangles we need more than that:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"A list of points\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Additional list of indices, that point to vertices' list\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"A strategy to help us interpret how to fetch triangles\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Indices types\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There are three major strategies to interpret the list of indices defined by\", _jsx(_components.br, {}), \"\\n\", _jsx(_components.strong, {\n        children: \"microtess::triangles::indices\"\n      }), \" enum at the file \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"\u003cmicrotess/triangles.h\u003e\"\n        })\n      })]\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/tess/triangles.gif\",\n      className: \"w-3/4 h-fit mx-auto my-10\",\n      imgClass: \"p-5\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"1. \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"indices::TRIANGLES\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This is the simplest, every 3 consecutive indices define a triangle, for example:\", _jsx(_components.br, {}), \"\\n\", \"Suppose list of indices is \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"[0,1,2,3,4,5,6,7,8,9,10,11]\"\n        })\n      }), \", then there are 4 triangles.\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"First triangle has indices \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"[0, 1, 2]\"\n          })\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Second triangle has indices \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"[3, 4, 5]\"\n          })\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Third triangle has indices \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"[6, 7, 8]\"\n          })\n        })]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"And so on\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: _jsx(_components.strong, {\n        children: \"Advanatages\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"This method is very intuitive.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Can encode any batch of triangles.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: _jsx(_components.strong, {\n        children: \"Disadvanatages\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Consumes the most memory. If we have \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"n\"\n          })\n        }), \" triangles, then we will need \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"3*n\"\n          })\n        }), \" indices to encode them.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"2. \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"indices::TRIANGLES_FAN\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This one is the simple as well. We pick a base index (usually the first) and then pick every\\nconsecutive 2 indices.\", _jsx(_components.br, {}), \"\\n\", \"Suppose list of indices is \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"[0,1,2,3,4,5,6,7,8,9,10,11,12]\"\n        })\n      }), \", then there are 6 triangles.\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"First triangle has indices \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"[0, 1, 2]\"\n          })\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Second triangle has indices \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"[0, 2, 3]\"\n          })\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Third triangle has indices \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"[0, 4, 5]\"\n          })\n        })]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"And so on\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: _jsx(_components.strong, {\n        children: \"Advanatages\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"This method is intuitive.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"It is easy on memory. If we have \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"n\"\n          })\n        }), \" triangles, then we will need\", _jsx(_components.br, {}), \"\\n\", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"2*n + 1\"\n          })\n        }), \" indices. Much better than \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"indices::TRIANGLES\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: _jsx(_components.strong, {\n        children: \"Disadvanatages\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Cannot encode all triangle batches with it.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"May produce silver triangles\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [\"3. \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"indices::TRIANGLES_STRIP\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This one is the hardest. Every group of 3 adjacent vertices forms a triangle. The face direction of the\", _jsx(_components.br, {}), \"\\n\", \"strip is determined by the winding of the first triangle. Each successive triangle will have its effective\\nface order reversed, so the system compensates for that by testing it in the opposite way.\", _jsx(_components.br, {}), \"\\n\", \"Suppose list of indices is \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"[0,1,2,3,4,5,6,7,8,9,10,11,12]\"\n        })\n      }), \", then there are 6 triangles.\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"First triangle has indices \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"[0, 1, 2]\"\n          })\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Second triangle has indices \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"[3, 2, 1]\"\n          })\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Third triangle has indices \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"[2, 3, 4]\"\n          })\n        })]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"And so on\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: _jsx(_components.strong, {\n        children: \"Advanatages\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"It is the best on memory. If we have \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"n\"\n          })\n        }), \" triangles, then we will need\", _jsx(_components.br, {}), \"\\n\", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"n + 2\"\n          })\n        }), \" indices.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Can encode any batch with this method using degenerate triangles trick.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: _jsx(_components.strong, {\n        children: \"Disadvanatages\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"This method is not intuitive.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Triangles Iteration\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"One can easily iterate triangles encoded in an indices list using the \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"microtess::triangles::iterate_triangles\"\n        })\n      }), \" method.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"/**\\n  * Iterate triangles encoded in a list of indices\\n  * @tparam iterator_callback a callback struct or lambda\\n  * @param indices pointer to indices array\\n  * @param size size of indices list\\n  * @param type the type of triangles\\n  * @param callback the callback instance\\n  */\\ntemplate\u003ctypename iterator_callback\u003e\\nvoid iterate_triangles(const index *indices,\\n                       const index \u0026size,\\n                       const enum triangles::indices \u0026type,\\n                       const iterator_callback \u0026 callback);\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Example\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"using index = unsigned int;\\nindex indices[6] {0, 1, 2, 3, 4, 5};\\n\\niterate_triangles(indices, 6, indices::TRIANGLES,\\n      [\u0026](const index triangle_index, \\n          const index first_index, const index second_index, const index third_index,\\n          const index edge_0_id, const index edge_1_id, const index edge_2_id) {\\n            std::cout \u003c\u003c 'outputing triangle #' \u003c\u003c triangle_index \u003c\u003c std::endl\\n                      \u003c\u003c 'triangle is (' \u003c\u003c first_index \u003c\u003c '-' \u003c\u003c second_index \u003c\u003c '-'\\n                      \u003c\u003c third_index \u003c\u003c ')' \u003c\u003c std::endl;\\n          }\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"If you don't like lambdas, you can implement a \", _jsx(_components.code, {\n        children: \"struct\"\n      }), \" that implements the \", _jsx(_components.code, {\n        children: \"operator()\"\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}},"frontMatter":{},"document":{"name":"docs","logo":"/logos/microtess-512-logo.png","groups":[{"title":"Getting Started","items":[{"title":"Setup","route":"getting-started/setup","path":"content/docs/micro-tess/setup.mdx"},{"title":"Features","route":"getting-started/features","path":"content/docs/micro-tess/features.mdx"}]},{"title":"Concepts","items":[{"title":"Numbers","route":"concepts/numbers","path":"content/docs/micro-tess/numbers.mdx"},{"title":"Triangles","route":"concepts/triangles","path":"content/docs/micro-tess/triangles.mdx"}]},{"title":"Algorithms","items":[{"title":"Path Fill","route":"algorithms/path-fill","path":"content/docs/micro-tess/path-fill.mdx"},{"title":"Path Stroke","route":"algorithms/path-stroke","path":"content/docs/micro-tess/path-stroke.mdx"},{"title":"Planar Subdivision","route":"algorithms/planar-subdivision","path":"content/docs/micro-tess/planar-subdivision.mdx"},{"title":"Stroke Tessellation","route":"algorithms/stroke","path":"content/docs/micro-tess/stroke.mdx"},{"title":"Ear Clipping Triangulation","route":"algorithms/ear-clipping","path":"content/docs/micro-tess/ear-clipping.mdx"},{"title":"Monotone Triangulation","route":"algorithms/monotone","path":"content/docs/micro-tess/monotone.mdx"},{"title":"Fan Triangulation","route":"algorithms/fan","path":"content/docs/micro-tess/fan.mdx"},{"title":"Bezier Curve Divider","route":"algorithms/bezier-curve-divider","path":"content/docs/micro-tess/bezier-curve-divider.mdx"},{"title":"Elliptic Arc Divider","route":"algorithms/elliptic-arc-divider","path":"content/docs/micro-tess/elliptic-arc-divider.mdx"},{"title":"Bezier Patch","route":"algorithms/bezier-patch","path":"content/docs/micro-tess/bezier-patch.mdx"}]}],"__map":{"getting-started/setup":"content/docs/micro-tess/setup.mdx","getting-started/features":"content/docs/micro-tess/features.mdx","concepts/numbers":"content/docs/micro-tess/numbers.mdx","concepts/triangles":"content/docs/micro-tess/triangles.mdx","algorithms/path-fill":"content/docs/micro-tess/path-fill.mdx","algorithms/path-stroke":"content/docs/micro-tess/path-stroke.mdx","algorithms/planar-subdivision":"content/docs/micro-tess/planar-subdivision.mdx","algorithms/stroke":"content/docs/micro-tess/stroke.mdx","algorithms/ear-clipping":"content/docs/micro-tess/ear-clipping.mdx","algorithms/monotone":"content/docs/micro-tess/monotone.mdx","algorithms/fan":"content/docs/micro-tess/fan.mdx","algorithms/bezier-curve-divider":"content/docs/micro-tess/bezier-curve-divider.mdx","algorithms/elliptic-arc-divider":"content/docs/micro-tess/elliptic-arc-divider.mdx","algorithms/bezier-patch":"content/docs/micro-tess/bezier-patch.mdx"}}}},"__N_SSG":true},"page":"/docs/micro-tess/[[...slug]]","query":{"slug":["concepts","triangles"]},"buildId":"dV491GG50l9Rddb8EbHVQ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>