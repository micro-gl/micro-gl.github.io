<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/1bff620fc812fa42.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1bff620fc812fa42.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-7477d36a73a3487c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8050cb959e6fa9ab.js" defer=""></script><script src="/_next/static/chunks/d7eeaac4-dbfd17fa893b1a6b.js" defer=""></script><script src="/_next/static/chunks/d64684d8-af995873706b0ebb.js" defer=""></script><script src="/_next/static/chunks/949-00a18eddf445c2d2.js" defer=""></script><script src="/_next/static/chunks/269-e752981b20d98295.js" defer=""></script><script src="/_next/static/chunks/pages/docs/micro-tess/%5B%5B...slug%5D%5D-6c0eb77f38937422.js" defer=""></script><script src="/_next/static/FGDItndIFWQmwD2rGZksw/_buildManifest.js" defer=""></script><script src="/_next/static/FGDItndIFWQmwD2rGZksw/_ssgManifest.js" defer=""></script></head><body class="w-screen h-screen"><div id="__next"></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"slug":"algorithms/planar-subdivision","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    li: \"li\",\n    code: \"code\",\n    h3: \"h3\",\n    em: \"em\",\n    h2: \"h2\",\n    blockquote: \"blockquote\",\n    br: \"br\",\n    pre: \"pre\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Introduction\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Planarize Division\"\n      }), \" Tessellates any collection of polygons of any type\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Supports \", _jsx(_components.strong, {\n          children: \"Fill Rules\"\n        }), \" - \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"even-odd\"\n          })\n        }), \" and \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"non-zero\"\n          })\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Numerically stable\"\n        }), \". Can tessellate with any number \", _jsx(_components.strong, {\n          children: \"precision\"\n        }), \": \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"Q\"\n          })\n        }), \" (fixed point), \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"float\"\n          })\n        }), \" and \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"double\"\n          })\n        })]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Includes geometric optimizations\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Allocator-aware\"\n        }), \" so you can use it in any computer memory model\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"3\"\n        }), \" Configurable tessellation \", _jsx(_components.strong, {\n          children: \"qualities\"\n        })]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Debuggable messages flag with macro definition (this will require stdlib)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Debuggable optional approximate trapezes output\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Optional boundary info output\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"If randomization is incorporated at the algorithm edge-wise, this is the fastest algorithm on\\naverage with \", _jsx(_components.code, {\n          children: \"O(n*log(n))\"\n        }), \" performance for any type of polygons and multi-polygons. Currently, the\\nper edge randomization was disabled because it might make the implementation less stable, but I might\\nre-add it with a flag. Also, partial randomization can be accomplished by randomizing the polygon.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Fill Rules\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"These can be chosen by the Enum \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"microtess::fill_rule\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"fill_rule::non_zero\"\n          })\n        }), \" - only includes subdivisions, which have a non-zero winding number.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"fill_rule::even_odd\"\n          })\n        }), \" - only includes subdivisions, which have odd winding number.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Tessellation Quality\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"These can be chosen by the Enum \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"microtess::tess_quality\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"tess_quality::fine\"\n          })\n        }), \" - The fastest algorithm, but may produce zero area triangles on the\\nboundary because it fan triangulates the approximate trapezes. might be a problem if you are using SDF based AA\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"tess_quality::better\"\n          })\n        }), \" - A bit slower and might be susceptible for other issues, but produces\\ntriangles out of each trapeze in a way similar to ear clipping, this\\nfights zero area triangles on the boundary, so you can use SDF AA\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"tess_quality::prettier_with_extra_vertices\"\n          })\n        }), \" - fast algorithm, that produces eye pleasing results,\\nbut uses around x2 memory for indices because it adds a center vertex in a trapeze and therefore adds\\ntwo more triangles per trapeze on average\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"tess_quality::worst_visuals_but_fast_and_constant_memory\"\n          })\n        }), \" (TBD) - the worst algorithm visually, as it will\\ncreate 2 triangles per trapeze, BUT let's not forget each trapeze is an approximation, therefore cracks will\\nshow up in many cases. Also, this will have 2 triangles per trapeze so this is the most memory efficient\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Input\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Input to the algorithm is\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Fill rule enum \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"microtess::fill_rule\"\n          })\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Tess quality enum \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"microtess::tess_quality\"\n          })\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Any iterable container which stores collections of collections of vertices, Each collection is a single polygon,\\nand you can have as many as you want. In this example, I use my brewed container \", _jsx(_components.code, {\n          children: \"chunker\"\n        }), \", but you can\\nuse any standard one like a vector of vectors of vertices (\", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"std::vector\u003cvector\u003cvec2\u003cnumber_type\u003e\u003e\u003e\"\n          })\n        }), \").\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Output variables to be filled by the algorithm\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Optional \", _jsx(_components.strong, {\n          children: \"allocator\"\n        }), \" for computation\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Output\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The algorithm output in the example below:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Will fill The \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"output_triangles_type\"\n          })\n        }), \" for you to know how to iterate the triangles (\", _jsx(_components.em, {\n          children: \"TRIANGLES/FAN/STRIP\"\n        }), \")\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Will fill the user supplied \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"output_vertices\"\n          })\n        }), \" container with triangulation vertices.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Will fill the user supplied \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"output_indices\"\n          })\n        }), \" container with triangulation indices.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Will (\", _jsx(_components.strong, {\n          children: \"optionally\"\n        }), \") fill the user supplied \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"output_boundary_info\"\n          })\n        }), \" container for you to know how to identify the boundary.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Will (\", _jsx(_components.strong, {\n          children: \"optionally\"\n        }), \") fill the user supplied \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"output_optional_approximate_trapezes\"\n          })\n        }), \" container for you to roughly understand the trapezes.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Debugging\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you are seeing bugs with the tessellation, try the following\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Set \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"APPLY_MERGE\"\n          })\n        }), \" template argument to \", _jsx(_components.code, {\n          children: \"false\"\n        }), \", this optimization might be producing problems.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Try increasing \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"MAX_ITERATIONS\"\n          })\n        }), \" template argument. Your algorithm might need more iterations if\\none of your polygons is huge. This argument is a fail safe way to exit an infinite loop if one shoudl occur.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Add \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"#define MICROTESS_PLANAR_DEBUG_MESSAGES\"\n          })\n        }), \" before all other includes. This should give messages and throw\\nexceptions when the algorithm 'feels' things are wrong, so this can give you info.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Try increasing the precision of the \", _jsx(_components.code, {\n          children: \"number\"\n        }), \" type of the vertices:\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"If using \", _jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"Q\"\n              })\n            }), \", try increasing precision bits. \", _jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"Q\u003c8\u003e -\u003e Q\u003c15\u003e\"\n              })\n            })]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"If using \", _jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"float\"\n              })\n            }), \", then try \", _jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"double\"\n              })\n            }), \" etc..\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Example\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"taken from \", _jsx(_components.code, {\n          children: \"examples/example_geometry_complex_to_planar_subdivision.cpp\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      style: {\n        margin: \"auto\"\n      },\n      children: _jsx(\"img\", {\n        src: \"/images/tess/planar-sub-1.png\",\n        style: {\n          height: \"250px\",\n          margin: \"auto\"\n        }\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The example demonstrates usage of different linear containers (including the packaged non standard \", _jsx(_components.code, {\n        children: \"dynamic_array\"\n      }), \").\", _jsx(_components.br, {}), \"\\n\", \"The example also demonstrates different number types such as fixed point integer(\", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"Q\"\n        })\n      }), \" numbers), float and doubles.\", _jsx(_components.br, {}), \"\\n\", \"Tessellation computation is only \", _jsx(_components.strong, {\n        children: \"16\"\n      }), \" lines of code.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I use the \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"microgl\"\n        })\n      }), \" project to render the tessellation.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Tessellation is happening at lines \", _jsx(_components.code, {\n        children: \"#45\"\n      }), \"-\", _jsx(_components.code, {\n        children: \"#65\"\n      })]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\u0026lines=45-65\",\n        children: \"#define MICROGL_USE_EXTERNAL_MICRO_TESS\\n#include \\\"src/example.h\\\"\\n#include \u003cmicrogl/canvas.h\u003e\\n#include \u003cmicrogl/bitmaps/bitmap.h\u003e\\n#include \u003cmicrogl/pixel_coders/RGB888_PACKED_32.h\u003e\\n#include \u003cmicrogl/samplers/flat_color.h\u003e\\n#include \u003cmicrogl/math/Q.h\u003e\\n\\n#include \u003cmicro-tess/planarize_division.h\u003e\\n#include \u003cmicro-tess/static_array.h\u003e\\n#include \u003cmicro-tess/dynamic_array.h\u003e\\n#include \u003cmicro-tess/chunker.h\u003e\\n#include \u003cmicro-tess/std_rebind_allocator.h\u003e\\n#include \u003cvector\u003e\\n\\ntemplate\u003ctypename item\u003e\\nusing fixed_static_array = static_array\u003citem, 10000\u003e;\\n\\n// containers for collections of points (polygons) \\ntemplate\u003ctypename number\u003e\\nusing chunker_t = allocator_aware_chunker\u003cvertex2\u003cnumber\u003e, dynamic_array\u003e;\\n//using chunker_t = allocator_aware_chunker\u003cvertex2\u003cnumber\u003e, std::vector\u003e;\\n//using chunker_t = non_allocator_aware_chunker\u003cvertex2\u003cnumber\u003e, fixed_static_array\u003e;\\n\\n// containers templates for output containers\\ntemplate\u003ctypename item\u003e\\nusing container = dynamic_array\u003citem\u003e;\\n//using container = std::vector\u003citem\u003e;\\n//using container = static_array\u003citem, 10000\u003e;\\n\\ntemplate \u003ctypename number\u003e\\ncontainer\u003cvertex2\u003cnumber\u003e\u003e box(float left, float top, float right,\\n                               float bottom, bool ccw=false) {\\n    using il = std::initializer_list\u003cvertex2\u003cnumber\u003e\u003e;\\n    if(!ccw)\\n        return il{{left,top}, {right,top}, {right,bottom}, {left,bottom}};\\n    return il{{left,top}, {left,bottom}, {right,bottom}, {right,top}};\\n};\\n\\ntemplate \u003ctypename number\u003e\\nchunker_t\u003cnumber\u003e poly_inter_star_2() {\\n    using il = std::initializer_list\u003cvertex2\u003cnumber\u003e\u003e;\\n    chunker_t\u003cnumber\u003e A;\\n\\n    A.push_back_and_cut(il{{150, 150}, {450,150},\\n                            {200,450}, {300,50},\\n                            {400,450}});\\n\\n    A.push_back_and_cut(il{{150/2, 150/2}, {450/2,150/2},\\n                            {200/2,450/2}, {300/2,50/2},\\n                            {400/2,450/2}});\\n\\n    A.push_back_and_cut(il{{150/10, 150/10}, {450/10,150/10},\\n                            {200/10,450/10}, {300/10,50/10},\\n                            {400/10,450/10}});\\n\\n    A.push_back_and_cut(box\u003cnumber\u003e(50,50,300,300, false));\\n    A.push_back_and_cut(box\u003cnumber\u003e(50,250,600,300, true));\\n    A.push_back_and_cut(box\u003cnumber\u003e(50,450,100,500, true));\\n\\n    return A;\\n}\\n\\nint main() {\\n    using number = float;\\n    // using number = double;\\n    // using number = Q\u003c2\u003e;\\n    // using number = Q\u003c4\u003e;\\n    // using number = Q\u003c8\u003e;\\n    // using number = Q\u003c12\u003e;\\n    // using number = Q\u003c15\u003e;\\n    // using number = Q\u003c16\u003e;\\n\\n    // microgl drawing setup START\\n    using Canvas24= canvas\u003cbitmap\u003cRGB888_PACKED_32\u003e\u003e;\\n    sampling::flat_color\u003c\u003e color_red {{255, 0, 255, 255}};\\n    Canvas24 canvas(640, 480);\\n    // microgl drawing setup END\\n\\n    auto render_polygon = [\u0026](const chunker_t\u003cnumber\u003e \u0026 pieces) {\\n        using index = unsigned int;\\n\\n        // Algorithm START\\n        // output tess vertices\\n        container\u003cvertex2\u003cnumber\u003e\u003e output_vertices;\\n        // output tess indices\\n        container\u003cindex\u003e output_indices;\\n        // output optional approximate trapezes\\n        container\u003cvertex2\u003cnumber\u003e\u003e output_optional_approximate_trapezes;\\n        // output optional boundary info\\n        container\u003cmicrotess::triangles::boundary_info\u003e output_boundary;\\n        // output triangles indices type\\n        microtess::triangles::indices output_triangles_type;\\n        // optional computation allocator\\n        microtess::std_rebind_allocator\u003c\u003e allocator;\\n        // define algorithm\\n        using psd = microtess::planarize_division\u003c\\n                            number,\\n                            decltype(output_vertices),\\n                            decltype(output_indices),\\n                            decltype(output_boundary)\u003e;\\n                            decltype(allocator)\u003e;\\n        // compute algorithm\\n        psd::template compute\u003cdecltype(pieces)\u003e(pieces,\\n                        microtess::fill_rule::even_odd,\\n                        microtess::tess_quality::better,\\n                        output_vertices, \\n                        output_triangles_type, \\n                        output_indices,\\n                        \u0026output_boundary, \\n                        \u0026output_optional_approximate_trapezes,\\n                        allocator);\\n        // Algorithm END\\n\\n        canvas.clear({255, 255, 255, 255});\\n        canvas.drawTriangles\u003cblendmode::Normal, porterduff::None\u003c\u003e, false\u003e(\\n                color_red,\\n                matrix_3x3\u003cnumber\u003e::identity(),\\n                output_vertices.data(),\\n                (vertex2\u003cnumber\u003e *)nullptr,\\n                output_indices.data(),\\n                output_boundary.data(),\\n                output_indices.size(),\\n                output_triangles_type,\\n                255);\\n\\n        canvas.drawTrianglesWireframe({0,0,0,255},\\n                            matrix_3x3\u003cnumber\u003e::identity(),\\n                            output_vertices.data(),\\n                            output_indices.data(),\\n                            output_indices.size(),\\n                            output_triangles_type,\\n                            40);\\n\\n        for (index ix = 0; ix \u003c output_optional_approximate_trapezes.size(); ix+=4)\\n            canvas.drawWuLinePath({0, 0, 0, 255},\\n                                  \u0026output_optional_approximate_trapezes[ix], 4, true);\\n    };\\n\\n    auto render = [\u0026](void*, void*, void*) -\u003e void {\\n        static auto polygons = poly_inter_star_2\u003cnumber\u003e();\\n        render_polygon(polygons);\\n    };\\n\\n    example_run(\u0026canvas, render);\\n}\\n\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"frontMatter":{},"document":{"name":"docs","groups":[{"title":"Getting Started","items":[{"title":"Setup","route":"getting-started/setup","path":"content/docs/micro-tess/setup.mdx"},{"title":"Features","route":"getting-started/features","path":"content/docs/micro-tess/features.mdx"}]},{"title":"Concepts","items":[{"title":"Numbers","route":"concepts/numbers","path":"content/docs/micro-tess/numbers.mdx"},{"title":"Triangles","route":"concepts/triangles","path":"content/docs/micro-tess/triangles.mdx"}]},{"title":"Algorithms","items":[{"title":"Path Fill","route":"algorithms/path-fill","path":"content/docs/micro-tess/path-fill.mdx"},{"title":"Path Stroke","route":"algorithms/path-stroke","path":"content/docs/micro-tess/path-stroke.mdx"},{"title":"Planar Subdivision","route":"algorithms/planar-subdivision","path":"content/docs/micro-tess/planar-subdivision.mdx"},{"title":"Stroke Tessellation","route":"algorithms/stroke","path":"content/docs/micro-tess/stroke.mdx"},{"title":"Ear Clipping Triangulation","route":"algorithms/ear-clipping","path":"content/docs/micro-tess/ear-clipping.mdx"},{"title":"Monotone Triangulation","route":"algorithms/monotone","path":"content/docs/micro-tess/monotone.mdx"},{"title":"Fan Triangulation","route":"algorithms/fan","path":"content/docs/micro-tess/fan.mdx"},{"title":"Bezier Curve Divider","route":"algorithms/bezier-curve-divider","path":"content/docs/micro-tess/bezier-curve-divider.mdx"},{"title":"Elliptic Arc Divider","route":"algorithms/elliptic-arc-divider","path":"content/docs/micro-tess/elliptic-arc-divider.mdx"},{"title":"Bezier Patch","route":"algorithms/bezier-patch","path":"content/docs/micro-tess/bezier-patch.mdx"}]}],"__map":{"getting-started/setup":"content/docs/micro-tess/setup.mdx","getting-started/features":"content/docs/micro-tess/features.mdx","concepts/numbers":"content/docs/micro-tess/numbers.mdx","concepts/triangles":"content/docs/micro-tess/triangles.mdx","algorithms/path-fill":"content/docs/micro-tess/path-fill.mdx","algorithms/path-stroke":"content/docs/micro-tess/path-stroke.mdx","algorithms/planar-subdivision":"content/docs/micro-tess/planar-subdivision.mdx","algorithms/stroke":"content/docs/micro-tess/stroke.mdx","algorithms/ear-clipping":"content/docs/micro-tess/ear-clipping.mdx","algorithms/monotone":"content/docs/micro-tess/monotone.mdx","algorithms/fan":"content/docs/micro-tess/fan.mdx","algorithms/bezier-curve-divider":"content/docs/micro-tess/bezier-curve-divider.mdx","algorithms/elliptic-arc-divider":"content/docs/micro-tess/elliptic-arc-divider.mdx","algorithms/bezier-patch":"content/docs/micro-tess/bezier-patch.mdx"}}}},"__N_SSG":true},"page":"/docs/micro-tess/[[...slug]]","query":{"slug":["algorithms","planar-subdivision"]},"buildId":"FGDItndIFWQmwD2rGZksw","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>