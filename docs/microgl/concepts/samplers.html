<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/cbbeacaae0822a8e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cbbeacaae0822a8e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-7477d36a73a3487c.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8050cb959e6fa9ab.js" defer=""></script><script src="/_next/static/chunks/d7eeaac4-dbfd17fa893b1a6b.js" defer=""></script><script src="/_next/static/chunks/d64684d8-af995873706b0ebb.js" defer=""></script><script src="/_next/static/chunks/949-00a18eddf445c2d2.js" defer=""></script><script src="/_next/static/chunks/269-e752981b20d98295.js" defer=""></script><script src="/_next/static/chunks/pages/docs/microgl/%5B%5B...slug%5D%5D-ce4506aec50e28ba.js" defer=""></script><script src="/_next/static/0P7kkRNH6w5CvJwoyulFj/_buildManifest.js" defer=""></script><script src="/_next/static/0P7kkRNH6w5CvJwoyulFj/_ssgManifest.js" defer=""></script></head><body class="w-screen h-screen"><div id="__next"></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"data":{"logo":"/logos//microgl-512-logo.png","slug":"concepts/samplers","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    strong: \"strong\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    pre: \"pre\",\n    blockquote: \"blockquote\",\n    h3: \"h3\",\n    a: \"a\"\n  }, _provideComponents(), props.components), {Image} = _components;\n  if (!Image) _missingMdxReference(\"Image\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Introduction\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Samplers\"\n      }), \" are a first class citizen in \", _jsx(_components.code, {\n        children: \"microgl\"\n      }), \". think of them as an object,\\nthat can be sampled in the normalized unit square.\"]\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/unit_square.png\",\n      className: \"w-[250px] h-[250px] my-10 mx-auto\",\n      imgClass: \"\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Samplers can be anything, that can be sampled such as\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"a fixed color\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"a gradient\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"a texture (image)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"effects\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Samplers can be though of as 2d shaders\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Sampler interface\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"samplers are implemented as classes with the following interface.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"struct half_sampler_t {\\n    // rgba info\\n    using rgba = rgba_t\u003c8, 8, 8, 0\u003e;\\n\\n    // the sampler method\\n    inline void sample(const int u, const int v,\\n                        const unsigned bits,\\n                        color_t \u0026output) const {\\n        const unsigned half = (1u\u003c\u003c(bits-1));\\n        output = {255, 0, 0};\\n        if(u \u003e half)\\n          output = {0, 255, 0};\\n    }\\n\\n};\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"at it's basic form, a sampler should publish it's rgba quantitized info and a sample method,\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"void sample(const int u, const int v, const unsigned bits, color_t \u0026output)\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"where \", _jsx(_components.code, {\n        children: \"u\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"v\"\n      }), \" are \", _jsx(_components.code, {\n        children: \"uv\"\n      }), \" coordinates handed as fixed point integers with \", _jsx(_components.code, {\n        children: \"bits\"\n      }), \" precision, this means that:\\n\", _jsx(_components.code, {\n        children: \"1\u003c\u003cbits\"\n      }), \" is like \", _jsx(_components.code, {\n        children: \"1\"\n      }), \". you can also transform \", _jsx(_components.code, {\n        children: \"uv\"\n      }), \" coordinates to \", _jsx(_components.code, {\n        children: \"float\"\n      }), \" point with\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"float uf = float(u)/float(1u\u003c\u003cbits)\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.code, {\n          children: \"float vf = float(v)/float(1u\u003c\u003cbits)\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"if you want to sample from a different number system such as float, double, q, you can use\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"#include \u003cmicrogl/sampler.h\u003e\\n\\nhalf_sampler_t half_sampler;\\ncolor_t output;\\nfloat u = 0.2f, v = 0.33f;\\n\\nsampling::sample(half_sampler, u, v, microgl::precision::high, output);\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"you can also inherit from \", _jsx(_components.strong, {\n          children: '\u003cmicrogl/sampler.h\u003e'\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [\"Samplers shipped with \", _jsx(_components.code, {\n        children: \"microgl\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"microgl is packed with the following samplers\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"1. Texture Sampler\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"defined at \", _jsx(_components.code, {\n          children: \"\u003cmicrogl/samplers/texture.h\u003e\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"example at \", _jsx(_components.code, {\n          children: \"/examples/example_sampler_texture.cpp\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"example at \", _jsx(_components.code, {\n          children: \"/examples/example_sampler_texture_wrap.cpp\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This sampler holds a \", _jsx(_components.a, {\n        href: \"bitmap\",\n        children: \"bitmap\"\n      }), \" and samples from it\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"template \u003ctypename Bitmap,\\n          texture_filter filter=texture_filter::NearestNeighboor,\\n          bool tint=false,\\n          texture_wrap wrap_u=texture_wrap::None,\\n          texture_wrap wrap_v=texture_wrap::None\u003e\\nstruct texture {\\n  ...\\n\\n    // constructors\\n    texture()\\n    texture(Bitmap * bitmap)\\n    texture(Bitmap * bitmap, const color_t \u0026tint_color)\\n\\n    // public interface\\n    void updateBitmap(Bitmap * bitmap)\\n    Bitmap \u0026 bitmap()\\n    void updateBorderColor(const color_t \u0026 color)\\n    void updateTintColor(const color_t \u0026 color)\\n    inline void sample(const rint u, const rint v,\\n                            const uint8_t bits,\\n                            color_t \u0026output) const    \\n  ...\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"where:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"Bitmap\"\n          })\n        }), \" is the bitmap type to sampler from\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"filter\"\n          })\n        }), \" is one of\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: _jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"texture_filter::NearestNeighboor\"\n              })\n            })\n          }), \"\\n\", _jsx(_components.li, {\n            children: _jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"texture_filter::Bilinear\"\n              })\n            })\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"tint\"\n          })\n        }), \" is a flag to enable color tinting, off by default\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"wrap_u\"\n          })\n        }), \" indicates how to handle horizontal sampling overflows, one of\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"texture_wrap::None\"\n              })\n            }), \" - most economic\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"texture_wrap::Clamp\"\n              })\n            }), \" - clamp overflow to 1\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"texture_wrap::ClampToBorderColor\"\n              })\n            }), \" - overflows will sample from border color\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"texture_wrap::Repeat\"\n              })\n            }), \" - overflows will repeat in cyclic order\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"wrap_v\"\n          })\n        }), \" same as \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"wrap_u\"\n          })\n        }), \" but for vertical sampling overflows\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"a texture will automatically use the \", _jsx(_components.strong, {\n          children: \"rgba\"\n        }), \" info of the bitmap it samples from\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/sampler_texture.png\",\n      className: \"w-[250px] h-[250px] my-10 mx-auto\",\n      imgClass: \"\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"2. Flat Color Sampler\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"defined at \", _jsx(_components.code, {\n          children: \"\u003cmicrogl/samplers/flat_color.h\u003e\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"example at \", _jsx(_components.code, {\n          children: \"/examples/example_sampler_flat_color.cpp\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"this is a very trivial sampler that samples a single color, it's declaration is\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"template\u003ctypename rgba_=rgba_t\u003c8,8,8,0\u003e\u003e\\nstruct flat_color {\\n    // rgba info\\n    using rgba = rgba_;\\n\\n    // constructors\\n    explicit flat_color()\\n    explicit flat_color(const color_t \u0026 $color)\\n\\n    // color\\n    color_t color;\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/sampler_flat.png\",\n      className: \"w-[250px] h-[250px] my-10 mx-auto\",\n      imgClass: \"\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"2. Line Gradient Sampler\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"defined at \", _jsx(_components.code, {\n          children: \"\u003cmicrogl/samplers/line_linear_gradient.h\u003e\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"example at \", _jsx(_components.code, {\n          children: \"/examples/example_sampler_gradient_line.cpp\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"the line gradient defines color stops on a line on which it samples. The line definition\\nis relative to unit rectangle.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"template \u003ctypename number, // the number type\\n          unsigned N=10, // the number of stops\\n          typename rgba_=rgba_t\u003c8,8,8,0\u003e, // the rgba info\\n          enum precision $precision=precision::medium, // the precision\\n          bool useBigIntegers=false\u003e // big integers are required for high precision\\nstruct line_linear_gradient {\\n    using rgba = rgba_;\\n\\n    // constructor\\n    line_linear_gradient()\\n    line_linear_gradient(const vec2\u003cnumber\u003e \u0026 start, const vec2\u003cnumber\u003e \u0026 end)\\n\\n    // set a new line relative to the unit rectangle\\n    void setNewLine(const vec2\u003cnumber\u003e \u0026 start, const vec2\u003cnumber\u003e \u0026 end)\\n    // add a new color stop on a fraction of the line\\n    void addStop(const number \u0026 where, const color_t \u0026color)\\n}    \\n\"\n      })\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"the \", _jsx(_components.code, {\n          children: \"number\"\n        }), \" template argument can be any type that implements a \", _jsx(_components.a, {\n          href: \"numbers\",\n          children: \"number system\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/sampler_line_linear_gradient.png\",\n      className: \"w-[250px] h-[250px] my-10 mx-auto\",\n      imgClass: \"\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"3. Angular Linear Gradient Sampler\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"defined at \", _jsx(_components.code, {\n          children: \"\u003cmicrogl/samplers/angular_linear_gradient.h\u003e\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"example at \", _jsx(_components.code, {\n          children: \"/examples/example_sampler_gradient_angular_linear.cpp\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This gradient is inferred by a given angle to create a line at the unit rectangle. the user can then\\ndefine the color stops.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"template \u003ctypename number, // the number type\\n          unsigned N=10, // the number of stops\\n          typename rgba_=rgba_t\u003c8,8,8,0\u003e, // the rgba info\\n          enum precision $precision=precision::medium, // the precision\\n          bool useBigIntegers=false\u003e // big integers are required for high precision\\nstruct angular_linear_gradient : public line_linear_gradient\u003c....\u003e {\\n    using rgba = rgba_;\\n\\n    // constructor\\n    angular_linear_gradient()\\n    angular_linear_gradient(const number \u0026 angle_degrees)\\n\\n    // set a new angle\\n    void setAngle(number angle_degrees)\\n    // add a new color stop on a fraction of the line defined by the angle\\n    void addStop(const number \u0026 where, const color_t \u0026color)\\n}    \\n\"\n      })\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/sampler_angular_linear_gradient.png\",\n      className: \"w-[250px] h-[250px] my-10 mx-auto\",\n      imgClass: \"\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4. Axial Linear Gradient Sampler\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"defined at \", _jsx(_components.code, {\n          children: \"\u003cmicrogl/samplers/axial_linear_gradient.h\u003e\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"example at \", _jsx(_components.code, {\n          children: \"/examples/example_sampler_gradient_axial.cpp\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This gradient is a faster variant if you need any number of stops but with angle,\\nthat is a modulu of 45 (0, 45, 90, 135, 180, 225, 270, 315, 360)\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"template \u003cunsigned degree=0, // the degree\\n          unsigned N=10, // the number of stops\\n          typename rgba_=rgba_t\u003c8,8,8,0\u003e, // the rgba info\\n          enum precision $precision=precision::medium, // the precision\\n          bool useBigIntegers=false\u003e // big integers are required for high precision\\nstruct axial_linear_gradient {\\n    using rgba = rgba_;\\n\\n    template \u003ctypename number\u003e\\n    void addStop(const number \u0026 where, const color_t \u0026color)\\n}    \\n\"\n      })\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/sampler_grad_axial.png\",\n      className: \"w-[250px] h-[250px] my-10 mx-auto\",\n      imgClass: \"\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"5. 2 Colors Gradient Sampler\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"defined at \", _jsx(_components.code, {\n          children: \"\u003cmicrogl/samplers/linear_gradient_2_colors.h\u003e\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"example at \", _jsx(_components.code, {\n          children: \"/examples/example_sampler_gradient_2_colors_fast.cpp\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This gradient is a very fast variant if you need only 2 colors stops but with angle,\\nthat is a modulu of 45 (0, 45, 90, 135, 180, 225, 270, 315, 360)\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"template \u003cunsigned degree=0, // the degree\\n          typename rgba_=rgba_t\u003c8,8,8,0\u003e, // the rgba info\\n          bool useBigIntegers=false\u003e // big integers are required for high precision\\nstruct linear_gradient_2_colors {\\n    using rgba = rgba_;\\n\\n    // constructor\\n    linear_gradient_2_colors(const color_t\u0026 color_1, const color_t\u0026 color_2)\\n\\n    color_t color1, color2;\\n}    \\n\"\n      })\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/sampler_grad_2_colors_fast.png\",\n      className: \"w-[250px] h-[250px] my-10 mx-auto\",\n      imgClass: \"\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"6. Fast Radial Gradient Sampler\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"defined at \", _jsx(_components.code, {\n          children: \"\u003cmicrogl/samplers/fast_radial_gradient.h\u003e\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"example at \", _jsx(_components.code, {\n          children: \"/examples/example_sampler_gradient_radial.cpp\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This gradient is a fast radial gradient.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"template \u003ctypename number, \\n          unsigned N=10, \\n          typename rgba_=rgba_t\u003c8,8,8,0\u003e,\\n          enum precision $precision=precision::medium, \\n          bool useBigIntegers=false\u003e\\nstruct fast_radial_gradient {\\n    using rgba = rgba_;\\n\\n    fast_radial_gradient();\\n    fast_radial_gradient(const number \u0026cx, const number \u0026cy, const number \u0026radius)\\n\\n    // set new radial with center x and y and radius\\n    void setNewRadial(const number \u0026cx, const number \u0026cy, const number \u0026radius)\\n    void addStop(const number \u0026 where, const color_t \u0026color)\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/sampler_grad_radial.png\",\n      className: \"w-[250px] h-[250px] my-10 mx-auto\",\n      imgClass: \"\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"7. Mask Sampler\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"defined at \", _jsx(_components.code, {\n          children: \"\u003cmicrogl/samplers/mask_sampler.h\u003e\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"example at \", _jsx(_components.code, {\n          children: \"/examples/example_sampler_masking_sampler.cpp\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This sampler can mask a sampler with a different sampler, this is very useful if you want to\\ndraw a masked image on the canvas.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"/**\\n* a sampler that masks a sampler with another sampler\\n*\\n* @tparam chrome the chrome channel config for mask sampler\\n* @tparam sampler_from a sampler you want to mask\\n* @tparam sampler_mask a sampler that acts as a mask\\n* @tparam alpha_fallback this sampler inherits the alpha bits of sampler_from,\\n*                        and in case it doesn't have an alpha channel (rgba::a=0),\\n*                        we can make an alpha channel with `alpha_fallback` bits\\n*/\\ntemplate\u003cmasks::chrome_mode chrome, // the chrome mode of the mask (the channel to use for mask)\\n        class sampler_from, // the sampler you want to mask\\n        class sampler_mask, // the mask sampler\\n        uint8_t alpha_fallback=8\u003e // \\nstruct mask_sampler {\\n\\n    // constructor\\n    mask_sampler(const sampler_from \u0026 from, const sampler_mask \u0026 mask)\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"the \", _jsx(_components.code, {\n        children: \"chrome\"\n      }), \" template argument is enum with the following values:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"#\",\n          children: \"chrome_mode::red_channel\"\n        }), \" - use the red channel as a mask of \", _jsx(_components.code, {\n          children: \"sampler_mask\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"#\",\n          children: \"chrome_mode::green_channel\"\n        }), \" - use the green channel as a mask of \", _jsx(_components.code, {\n          children: \"sampler_mask\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"#\",\n          children: \"chrome_mode::blue_channel\"\n        }), \" - use the blue channel as a mask of \", _jsx(_components.code, {\n          children: \"sampler_mask\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"#\",\n          children: \"chrome_mode::alpha_channel\"\n        }), \" - use the alpha channel as a mask of \", _jsx(_components.code, {\n          children: \"sampler_mask\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"#\",\n          children: \"chrome_mode::red_channel_inverted\"\n        }), \" - use the inverted red channel\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"#\",\n          children: \"chrome_mode::green_channel_inverted\"\n        }), \" - use the inverted green channel\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"#\",\n          children: \"chrome_mode::blue_channel_inverted\"\n        }), \" - use the inverted blue channel\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"#\",\n          children: \"chrome_mode::alpha_channel_inverted\"\n        }), \" - use the inverted alpha channel\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/sampler_masking.png\",\n      className: \"w-[250px] h-[250px] my-10 mx-auto\",\n      imgClass: \"\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"8. Checker Board Sampler\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"defined at \", _jsx(_components.code, {\n          children: \"\u003cmicrogl/samplers/checker_board.h\u003e\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"example at \", _jsx(_components.code, {\n          children: \"/examples/example_sampler_checkerboard.cpp\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This sampler can draw a checker board pattern with\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Configurable two colors\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Configurable horizontal and vertical splits\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"/**\\n  * checker board pattern sampler\\n  *\\n  * @tparam rgba_ the rgba info\\n  */\\ntemplate\u003ctypename rgba_=rgba_t\u003c8,8,8,0\u003e\u003e\\nstruct checker_board {\\n    using rgba = rgba_;\\n    \\n    /**\\n      * constructor\\n      *\\n      * @param color1 1st color\\n      * @param color2 2nd color\\n      * @param horizontal horizontal splits count\\n      * @param vertical vertical split count\\n      */\\n    explicit checker_board(const color_t \u0026 color1,\\n                            const color_t \u0026 color2,\\n                            unsigned horizontal=2,\\n                            unsigned vertical=2)\\n    }\\n\"\n      })\n    }), \"\\n\", _jsx(Image, {\n      src: \"/images/sampler_checker_board.png\",\n      className: \"w-[250px] h-[250px] my-10 mx-auto\",\n      imgClass: \"\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [_jsx(_components.code, {\n        children: \"microgl::sampling\"\n      }), \" namespace\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This namespace also defines the following utility methods\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"sample from another number system\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"sample uv coords from sampler with a different number system.\\nThis is handy because samplers work in quantized space to be more\\nefficient and sometimes it is not convenient. This method will convert\\nthe uv coords into fixed points and then sample from the sampler.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"/**\\n* @tparam Sampler the sampler type\\n* @tparam number the number type\\n* \\n* @param sampler the sampler reference \\n* @param u the u coord\\n* @param v the v coord\\n* @param p precision can be {low, medium, high, amazing}\\n* @param output output color\\n*/\\ntemplate\u003cclass Sampler, typename number\u003e\\ninline void sample(const Sampler \u0026 sampler,\\n                   const number \u0026u, const number \u0026v,\\n                   const enum microgl::precision \u0026p,\\n                   color_t \u0026output) {\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [_jsx(_components.code, {\n        children: \"base_sampler\"\n      }), \" class\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can extend this class to include other utility methods inside your class.\\nThis is a nice container, that can wrap samplers and also invoke their sampling\\nbehaviour via \", _jsx(_components.code, {\n        children: \"crpt\"\n      }), \" compile-time polymorphism. I prefer not to use it because it\\nmakes the definition a bit combersome and long with \", _jsx(_components.code, {\n        children: \"c++\"\n      }), \" templates quirks\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"/**\\n* @tparam rgba_ the rgba_t info type\\n* @tparam impl the type of the derived class\\n*/\\ntemplate\u003ctypename rgba_, typename impl\u003e\\nclass base_sampler\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}},"frontMatter":{},"document":{"name":"docs","logo":"/logos//microgl-512-logo.png","groups":[{"title":"Getting Started","items":[{"title":"Setup","route":"getting-started/setup","path":"content/docs/microgl/setup.mdx"},{"title":"Features","route":"getting-started/features","path":"content/docs/microgl/features.mdx"}]},{"title":"Concepts","items":[{"title":"Numbers","route":"concepts/numbers","path":"content/docs/microgl/numbers.mdx"},{"title":"Math","route":"concepts/math","path":"content/docs/microgl/math.mdx"},{"title":"RGBA","route":"concepts/rgba","path":"content/docs/microgl/rgba.mdx"},{"title":"Pixel Coders","route":"concepts/pixel-coders","path":"content/docs/microgl/pixel-coders.mdx"},{"title":"Samplers","route":"concepts/samplers","path":"content/docs/microgl/samplers.mdx"},{"title":"Composition","route":"concepts/composition","path":"content/docs/microgl/composition.mdx"},{"title":"Bitmaps","route":"concepts/bitmaps","path":"content/docs/microgl/bitmaps.mdx"},{"title":"3D Shaders","route":"concepts/3d","path":"content/docs/microgl/3d.mdx"},{"title":"Canvas","route":"concepts/canvas","path":"content/docs/microgl/canvas.mdx"}]},{"title":"Drawing","items":[{"title":"Rectangles","route":"drawing/rectangles","path":"content/docs/microgl/rectangles.mdx"},{"title":"Rounded Shapes","route":"drawing/rounded","path":"content/docs/microgl/rounded.mdx"},{"title":"Quadrilaterals","route":"drawing/quadrilaterals","path":"content/docs/microgl/quadrilaterals.mdx"},{"title":"Triangle","route":"drawing/triangle","path":"content/docs/microgl/triangle.mdx"},{"title":"Triangle Batches","route":"drawing/triangle-batches","path":"content/docs/microgl/triangle-batches.mdx"},{"title":"Polygons","route":"drawing/polygons","path":"content/docs/microgl/polygons.mdx"},{"title":"Masks","route":"drawing/masks","path":"content/docs/microgl/masks.mdx"},{"title":"Path Fills","route":"drawing/path-fills","path":"content/docs/microgl/path-fills.mdx"},{"title":"Path Strokes","route":"drawing/path-stroke","path":"content/docs/microgl/path-stroke.mdx"},{"title":"Bezier Patches","route":"drawing/bezier-patches","path":"content/docs/microgl/patches.mdx"},{"title":"Lines","route":"drawing/lines","path":"content/docs/microgl/lines.mdx"},{"title":"Text","route":"drawing/text","path":"content/docs/microgl/text.mdx"},{"title":"Gradients","route":"drawing/gradients","path":"content/docs/microgl/gradients.mdx"},{"title":"More Samplers","route":"drawing/more-samplers","path":"content/docs/microgl/more-samplers.mdx"},{"title":"3D","route":"drawing/3d","path":"content/docs/microgl/draw-3d.mdx"}]}],"__map":{"getting-started/setup":"content/docs/microgl/setup.mdx","getting-started/features":"content/docs/microgl/features.mdx","concepts/numbers":"content/docs/microgl/numbers.mdx","concepts/math":"content/docs/microgl/math.mdx","concepts/rgba":"content/docs/microgl/rgba.mdx","concepts/pixel-coders":"content/docs/microgl/pixel-coders.mdx","concepts/samplers":"content/docs/microgl/samplers.mdx","concepts/composition":"content/docs/microgl/composition.mdx","concepts/bitmaps":"content/docs/microgl/bitmaps.mdx","concepts/3d":"content/docs/microgl/3d.mdx","concepts/canvas":"content/docs/microgl/canvas.mdx","drawing/rectangles":"content/docs/microgl/rectangles.mdx","drawing/rounded":"content/docs/microgl/rounded.mdx","drawing/quadrilaterals":"content/docs/microgl/quadrilaterals.mdx","drawing/triangle":"content/docs/microgl/triangle.mdx","drawing/triangle-batches":"content/docs/microgl/triangle-batches.mdx","drawing/polygons":"content/docs/microgl/polygons.mdx","drawing/masks":"content/docs/microgl/masks.mdx","drawing/path-fills":"content/docs/microgl/path-fills.mdx","drawing/path-stroke":"content/docs/microgl/path-stroke.mdx","drawing/bezier-patches":"content/docs/microgl/patches.mdx","drawing/lines":"content/docs/microgl/lines.mdx","drawing/text":"content/docs/microgl/text.mdx","drawing/gradients":"content/docs/microgl/gradients.mdx","drawing/more-samplers":"content/docs/microgl/more-samplers.mdx","drawing/3d":"content/docs/microgl/draw-3d.mdx"}}}},"__N_SSG":true},"page":"/docs/microgl/[[...slug]]","query":{"slug":["concepts","samplers"]},"buildId":"0P7kkRNH6w5CvJwoyulFj","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>