most of `microgl` algorithms can use any of the following numbers types at compile-time:
- `Q` numbers
- `float` numbers
- `double` numbers
- any custom user defined number types will be available soon

## Q numbers
Q numbers are fixed point integers, that have configurable number of bits  
for the precision of the number.

```cpp
#include <microgl/Q.h>
// q_15 have 15 bits of precision
using q_15 = Q<15>;

q_15 q1{5}, q2{2};
q_15 q3 = q1/q2;
```

you can convert q numbers into other precision with
```cpp
Q<4> q4 = q3;
```

you can also cast them to other numbers
```cpp
float f1 = float(q4);
double d1 = float(q4);
int f1 = int(q4);
```

you can also construct them from other types
```cpp

Q<15> q1{0.00281f};
Q<15> q2 = 3.14f
```

you can also apply math function on them
```cpp

#include <microgl/Q.h>
#include <microgl/math.h>
// q_15 have 15 bits of precision
using q_15 = Q<15>;

Q<15> q1{9.32f};

auto q_sqrt = microgl::math::sqrt(q1);
auto q_abs = microgl::math::abs(q1);
```

you can use them inside a matrix
```cpp

#include <microgl/Q.h>
#include <microgl/matrix_3x3.h>

using q = Q<12>;

using mat = matrix_3x3<q>;
using mat_float = matrix_3x3<float>;

q angle{3.14f/2.f}
sine = microgl::math::sin(t*2);

mat identity = mat::identity();
mat rotation_pivot = mat::rotation(angle, 50, 50, 1, 1);
mat translate = mat::translate(100, 100);
mat scale = mat::scale(number_scale, number_scale);
mat shear_x = mat::shear_x(1.7f);

mat transform_matrix = translate * rotation_pivot;
```

you can use them inside other containers
```cpp

#include <microgl/Q.h>
#include <microgl/vec2.h>

using q = Q<12>;
using vec2 = vec2<q>;

vec2 vertex{5, 6};

vec2 v2 = transform_matrix * vertex;
auto v3 = v2.dot(vertex);
```

