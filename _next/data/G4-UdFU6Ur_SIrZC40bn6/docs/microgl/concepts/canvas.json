{"pageProps":{"data":{"slug":"concepts/canvas","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    strong: \"strong\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\",\n    blockquote: \"blockquote\",\n    pre: \"pre\",\n    h3: \"h3\",\n    br: \"br\",\n    em: \"em\",\n    h2: \"h2\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Introduction\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Canvas\"\n      }), \" is the main drawing concept in \", _jsx(_components.code, {\n        children: \"microgl\"\n      }), \". Canvas can be described as:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"An object with minimal state\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"An object that holds a \", _jsx(_components.a, {\n          href: \"bitmap\",\n          children: \"bitmap\"\n        }), \" to draw on\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"a bunch of methods to draw shapes on a bitmap using \", _jsx(_components.a, {\n          href: \"samplers\",\n          children: \"sampler\"\n        }), \" and \", _jsx(_components.a, {\n          href: \"3d\",\n          children: \"3d-shaders\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Canvas\"\n        }), \" origin (0, 0) is at the top left like photoshop and spans to the bottom and right\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Canvas can be found at \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"<microgl/canvas.h>\"\n        })\n      }), \" and using it is a template, that can be instantieated\\nwith the following signature:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"/**\\n * @tparam bitmap_type  the bitmap type\\n * @tparam options      the options bitset\\n */\\ntemplate<typename bitmap_type, uint8_t options=CANVAS_OPT_default>\\nclass canvas {\\npublic:\\n    // the canvas type\\n    using canvas_t = ...\\n    // the underlying bitmap type\\n    using bitmap_t = ...\\n    // the pixel type of the bitmap\\n    using pixel = ...\\n    // the pixel coder type of the bitmap\\n    using pixel_coder = ...\\n\\n    struct window_t {\\n        rect canvas_rect;\\n        rect clip_rect;\\n        int index_correction=0;\\n    };\\n\\n    static constexpr bool options_compress_bits() { return options&CANVAS_OPT_raster_COMPRESS_BITS; }\\n    static constexpr bool options_big_integers() { return options&CANVAS_OPT_2d_raster_USE_BIG_INT; }\\n    static constexpr bool options_avoid_overflow() { return options&CANVAS_OPT_2d_raster_AVOID_RENDER_WITH_OVERFLOWS; }\\n    static constexpr bool options_use_division() { return options&CANVAS_OPT_2d_raster_USE_DIVISION; }\\n\\n    struct render_options_t {\\n        uint8_t _2d_raster_bits_sub_pixel= options_big_integers() ? 8 : 4;\\n        uint8_t _2d_raster_bits_uv= options_big_integers() ? 15 : 10;\\n        uint8_t _3d_raster_bits_sub_pixel= options_big_integers() ? 8 : 4;\\n        uint8_t _3d_raster_bits_w= options_big_integers() ? 15 : 12;\\n    };\\n\\n    /**\\n     * ctor of canvas that receives a bitmap reference\\n     *\\n     * @param $bmp a bitmap reference\\n     */\\n    explicit canvas(bitmap_type * $bmp)\\n    /**\\n     * ctor of canvas that allocate a bitmap internally\\n     * @param width     width of canvas\\n     * @param height    height of canvas\\n     */\\n    canvas(int width, int height)\\n\\n\\n    /**\\n     * where to position the bitmap relative to the canvas, this feature\\n     * can help with block rendering, where the bitmap is smaller than the canvas\\n     * diensions.\\n     *\\n     * @param left relative to x=0\\n     * @param top relative to y=0\\n     * @param $bmp (Optional) the bitmap reference\\n     */\\n    void updateCanvasWindow(int left, int top, bitmap_type * $bmp=nullptr)\\n\\n    /**\\n     * given that we know the canvas size and the clip rect, calculate\\n     * the sub rectangle (intersection), where drawing is visible\\n     *\\n     * @return a rectangle\\n     */\\n    rect calculateEffectiveDrawRect()\\n\\n\\n    /**\\n     * get the canvas rectangle, should be (0, 0, width, height), unless\\n     * the sub windowing feature was used.\\n     * @return a rectangle\\n     */\\n    const rect & canvasWindowRect() const\\n\\n    // get the rendering options\\n    render_options_t & renderingOptions()\\n\\n    // get canvas width\\n    int width() const;\\n    // get canvas height\\n    int height() const;\\n    // get size of pixel\\n    unsigned int sizeofPixel() const;\\n    // get the pixels array from the underlying bitmap\\n    pixel * pixels() const;\\n    // get a pixel by position\\n    pixel & getPixel(int x, int y) const ;\\n    pixel & getPixel(int index) const ;\\n    // decode pixel color by position\\n    void getPixelColor(int index, color_t & output) const;\\n    void getPixelColor(int x, int y, color_t & output) const;\\n\\n    // get the pixel coder reference of the underlying bitmap\\n    const pixel_coder & coder() const;\\n\\n    // get the underlying bitmap pointer\\n    bitmap_type * bitmapCanvas() const;\\n\\n    .\\n    .\\n    .\\n    .\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Usage\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Canvas can be simply used with the following c++ code\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"#include <microgl/canvas.h>\\n#include <microgl/pixel_coders/RGB888_PACKED_32.h>\\n\\nusing Canvas24= canvas<bitmap<coder::RGB888_PACKED_32>>;\\n\\nCanvas24 canvas_1(640, 480);\\n\\n// or with a given bitmap\\nCanvas24 canvas_2(new bitmap<coder::RGB888_PACKED_32>(img_2.data, img_2.width, img_2.height))\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Clipping\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Canvas implements a clipping feature where you can specify a rectangle, that will draw every\\npixel inside it and NOT draw outside of it, by default, the clip rectangle is the dimensions\\nof the canvas window, which by default is the size of the underlying bitmap.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"public:\\n    /**\\n     * update the clipping rectangle of the canvas\\n     *\\n     * @param l left distance to x=0\\n     * @param t top distance to y=0\\n     * @param r right distance to x=0\\n     * @param b bottom distance to y=0\\n     */\\n    void updateClipRect(int l, int t, int r, int b)\\n    // get the clipping rectangle\\n    const rect & clipRect() const\\n\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Block Rendering and Windowing\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Canvas implements a block rendering feature, where you can move the canvas surface to\\nanother position. This can be leveraged to do the following:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Draw the canvas in blocks with a smaller bitmap and then copy it to external display\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"This is ofcourse slower than drawing on entire canvas at once.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"This is more memory friendly in memory constrained environments.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Use it when the underlying bitmap is smaller than the clip rect\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"public:\\n    /**\\n     * @param left relative to x=0\\n     * @param top relative to y=0\\n     * @param $bmp (Optional) the bitmap reference\\n     */\\n     void updateCanvasWindow(int left, int top, bitmap_type * $bmp=nullptr)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here are 2 examples of renderings, that used 1/4 and 1/2 of the canvas size\"\n    }), \"\\n\", _jsxs(\"div\", {\n      style: {\n        margin: \"auto\"\n      },\n      children: [_jsx(\"img\", {\n        src: \"/images/canvas_block_1.png\",\n        style: {\n          height: \"250px\",\n          display: \"inline-block\"\n        }\n      }), _jsx(\"img\", {\n        src: \"/images/canvas_block_2.png\",\n        style: {\n          height: \"250px\",\n          display: \"inline-block\"\n        }\n      })]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Examples at \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"/examples/example_blocks_----.cpp\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Canvas Options\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When the Canvas template is instantieated, it can be with a bitfield parameter to control some\\nthings. Options can be concatenated. Here are the current options:\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"CANVAS_OPT_2d_raster_USE_BIG_INT\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Use big integers for 2d rasterizer, this implies a 64 bits place holders\\nfor all or most calculations inside the rasterizer. bigger integers imply\\noverflow is harder to come by\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"CANVAS_OPT_2d_raster_USE_DIVISION\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Inside the 2d rasterizer, use division for uv-mapping, this reduces\\nthe number of bits used BUT is slower. Generally this HAS to be used\\non a forced 32 bit rasterizer, in case you want a pure 32 bit integers\\nonly during rasterization. Do not use it when in BIG INT mode.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"CANVAS_OPT_2d_raster_AVOID_RENDER_WITH_OVERFLOWS\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The 2d and 3d rasterizer can detect overflow of uv mapping, the detection\\nfeature is great for debugging the rasterizer. this flag enables detection\\nand if so, exits the rendering. This is helpful for when using a 32 bit mode,\\nwhere overflows are likely to happen\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"CANVAS_OPT_2d_raster_FORCE_32_BIT\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Use a true 32 bit mode in the 2d and 3d rasterizer, this means regular 32 bit integers\\nand also the usage of division in order to reduce overflow and also detecting\\nand exiting on overflows as they are likely to happen in 32 bit mode, if so,\\nplease adjust some of the render options bits in the canvas and make sure you\\nrender small geometries at a time\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"CANVAS_OPT_2d_raster_USE_DIVISION | CANVAS_OPT_2d_raster_AVOID_RENDER_WITH_OVERFLOWS | CANVAS_OPT_raster_COMPRESS_BITS\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"CANVAS_OPT_2d_raster_FORCE_64_BIT (default)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Force 64 bits\", _jsx(_components.br, {}), \"\\n\", \"CANVAS_OPT_2d_raster_USE_BIG_INT | CANVAS_OPT_2d_raster_AVOID_RENDER_WITH_OVERFLOWS\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Usage\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"#include <microgl/canvas.h>\\n#include <microgl/pixel_coders/RGB888_PACKED_32.h>\\n\\n\\nusing Bitmap= bitmap<coder::RGB888_PACKED_32>;\\nusing Canvas24= canvas<Bitmap, CANVAS_OPT_2d_raster_FORCE_32_BIT>;\\n\\nCanvas24 canvas_1(640, 480);\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Rendering Options\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"At any moment you can fine tune the precision (count of bits), that is spent on\\nthe 2d and 3d rasterizer via aquiring the rendering options\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"public:\\n  render_options_t & renderingOptions();\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Which return the \", _jsx(_components.code, {\n        children: \"render_options_t\"\n      }), \" struct\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"struct render_options_t {\\n    uint8_t _2d_raster_bits_sub_pixel= options_big_integers() ? 8 : 4;\\n    uint8_t _2d_raster_bits_uv= options_big_integers() ? 15 : 10;\\n    uint8_t _3d_raster_bits_sub_pixel= options_big_integers() ? 8 : 4;\\n    uint8_t _3d_raster_bits_w= options_big_integers() ? 15 : 12;\\n};\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: _jsx(_components.em, {\n        children: \"_2d_raster_bits_sub_pixel\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The number of bits spent on \", _jsx(_components.code, {\n        children: \"sub-pixel\"\n      }), \" precision. The more you spend, the smoother animation will\\nbe precieved.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: _jsx(_components.em, {\n        children: \"_2d_raster_bits_uv\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The number of bits spent on \", _jsx(_components.code, {\n        children: \"uv\"\n      }), \" precision. The more you spend, the better the sampling will look.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: _jsx(_components.em, {\n        children: \"_3d_raster_bits_sub_pixel\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The number of bits spent on \", _jsx(_components.code, {\n        children: \"sub-pixel\"\n      }), \" precision. The more you spend, the smoother animation will\\nbe precieved.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: _jsx(_components.em, {\n        children: \"_3d_raster_bits_w\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The number of bits spent on \", _jsx(_components.code, {\n        children: \"w\"\n      }), \" precision. The more you spend, then better interpolations (\", _jsx(_components.code, {\n        children: \"barycentric\"\n      }), \" coords)\\nwill be produced.\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"The trick is to fine tune these values based on 32/64 bit mode and the size of the shapes bounding boxes.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Supported Shapes\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Canvas can draw the following shapes with a \", _jsx(_components.a, {\n        href: \"samplers\",\n        children: \"sampler\"\n      }), \" and a matrix transform.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Rectangles\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Example at \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"/examples/example_draw_rect_transform.cpp\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/images/canvas_rect.png\",\n      style: {\n        height: \"250px\",\n        margin: \"auto\"\n      }\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Rounded Rectangles\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Example at \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"/examples/example_draw_rounded_rectangle.cpp\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/images/canvas_rounded_rect.png\",\n      style: {\n        height: \"250px\",\n        margin: \"auto\"\n      }\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Triangle\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"Example at \", _jsx(_components.strong, {\n            children: _jsx(_components.code, {\n              children: \"/examples/example_draw_triangle.cpp\"\n            })\n          })]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Example at \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"/examples/example_draw_triangles_matrix_transforms.cpp\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You can also draw triangles in batches\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/images/canvas_triangle.png\",\n      style: {\n        height: \"250px\",\n        margin: \"auto\"\n      }\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Polygon\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Examples at \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"/examples/example_draw_polygon.cpp\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"microgl\"\n      }), \" can draw convex, concave, simple, monotone, self intersecting and complex polygon.\\ni.e polygons of all types.\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/images/canvas_polygon.png\",\n      style: {\n        height: \"250px\",\n        margin: \"auto\"\n      }\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Circles\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Examples at \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"/examples/example_draw_circles.cpp\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/images/canvas_circle.png\",\n      style: {\n        height: \"250px\",\n        margin: \"auto\"\n      }\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Arcs\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Examples at \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"/examples/example_draw_arcs.cpp\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/images/canvas_arc.png\",\n      style: {\n        height: \"250px\",\n        margin: \"auto\"\n      }\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Pie\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Examples at \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"/examples/example_draw_pie.cpp\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/images/canvas_pie.png\",\n      style: {\n        height: \"250px\",\n        margin: \"auto\"\n      }\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Quadrilaterals (4 points with perspective)\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Examples at \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"/examples/example_draw_quadrilaterals.cpp\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/images/canvas_quadri.png\",\n      style: {\n        height: \"250px\",\n        margin: \"auto\"\n      }\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Masks\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Examples at \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"/examples/example_draw_masks.cpp\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/images/canvas_mask.png\",\n      style: {\n        height: \"250px\",\n        margin: \"auto\"\n      }\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Path fills\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Examples at \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"/examples/example_draw_path.cpp\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Paths are vector graphics shapes defined by lines, bezier paths, elliptic arcs and more.\\nWith them you can define multiple shapes, that when combined might for a complex polygon.\\nafter tessalation, the paths are filled using the \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"one-zero\"\n        })\n      }), \" or \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"even-odd\"\n        })\n      }), \" criterion\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/images/canvas_path.png\",\n      style: {\n        height: \"250px\",\n        margin: \"auto\"\n      }\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Path Strokes\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Examples at \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"/examples/example_draw_path_stroke.cpp\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Paths strokes are vector graphics paths defined by lines, bezier paths, arcs and more.\\nwhen tessalated, you can define things like:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"stroke dash pattern and offset (useful for animation)\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"stroke cap of \", _jsx(_components.code, {\n          children: \"butt\"\n        }), \", \", _jsx(_components.code, {\n          children: \"round\"\n        }), \", \", _jsx(_components.code, {\n          children: \"square\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"stroke line join of \", _jsx(_components.code, {\n          children: \"none\"\n        }), \", \", _jsx(_components.code, {\n          children: \"miter\"\n        }), \", \", _jsx(_components.code, {\n          children: \"miter_clip\"\n        }), \", \", _jsx(_components.code, {\n          children: \"round\"\n        }), \", \", _jsx(_components.code, {\n          children: \"bevel\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(\"div\", {\n      style: {\n        margin: \"auto\"\n      },\n      children: [_jsx(\"img\", {\n        src: \"/images/canvas_stroke.png\",\n        style: {\n          height: \"250px\",\n          display: \"inline-block\"\n        }\n      }), _jsx(\"img\", {\n        src: \"/images/canvas_stroke_dash.png\",\n        style: {\n          height: \"250px\",\n          display: \"inline-block\"\n        }\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Bezier Patches\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Examples at \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"/examples/example_draw_bezier_patch.cpp\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Bezier patches of 2nd and 3rd degree, Quadratic and Cubic orders are supported as well\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/images/canvas_bezier_patch.png\",\n      style: {\n        height: \"250px\",\n        margin: \"auto\"\n      }\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Lines (Wu lines)\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Examples at \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"/examples/example_3d_simple_pipeline.cpp\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Examples at \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"/examples/example_geometry_bezier_curve_divider.cpp\"\n          })\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Wu lines algorithm is supported, it is a fast DDA algorithm, supports anti-aliasing\\nbut is not very accurate.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/images/canvas_wu_lines.png\",\n      style: {\n        height: \"250px\",\n        margin: \"auto\"\n      }\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"frontMatter":{},"document":{"name":"docs","groups":[{"title":"Getting Started","items":[{"title":"Setup","route":"getting-started/setup","path":"content/docs/microgl/setup.mdx"},{"title":"Features","route":"getting-started/features","path":"content/docs/microgl/features.mdx"}]},{"title":"Concepts","items":[{"title":"Numbers","route":"concepts/numbers","path":"content/docs/microgl/numbers.mdx"},{"title":"Math","route":"concepts/math","path":"content/docs/microgl/math.mdx"},{"title":"RGBA","route":"concepts/rgba","path":"content/docs/microgl/rgba.mdx"},{"title":"Pixel Coders","route":"concepts/pixel-coders","path":"content/docs/microgl/pixel-coders.mdx"},{"title":"Samplers","route":"concepts/samplers","path":"content/docs/microgl/samplers.mdx"},{"title":"Composition","route":"concepts/composition","path":"content/docs/microgl/composition.mdx"},{"title":"Bitmaps","route":"concepts/bitmaps","path":"content/docs/microgl/bitmaps.mdx"},{"title":"3D Shaders","route":"concepts/3d","path":"content/docs/microgl/3d.mdx"},{"title":"Canvas","route":"concepts/canvas","path":"content/docs/microgl/canvas.mdx"}]},{"title":"Drawing","items":[{"title":"Rectangles","route":"drawing/rectangles","path":"content/docs/microgl/rectangles.mdx"},{"title":"Rounded Shapes","route":"drawing/rounded","path":"content/docs/microgl/rounded.mdx"},{"title":"Quadrilaterals","route":"drawing/quadrilaterals","path":"content/docs/microgl/quadrilaterals.mdx"},{"title":"Triangle","route":"drawing/triangle","path":"content/docs/microgl/triangle.mdx"},{"title":"Triangle Batches","route":"drawing/triangle-batches","path":"content/docs/microgl/triangle-batches.mdx"},{"title":"Polygons","route":"drawing/polygons","path":"content/docs/microgl/polygons.mdx"},{"title":"Masks","route":"drawing/masks","path":"content/docs/microgl/masks.mdx"},{"title":"Path Fills","route":"drawing/path-fills","path":"content/docs/microgl/path-fills.mdx"},{"title":"Path Strokes","route":"drawing/path-stroke","path":"content/docs/microgl/path-stroke.mdx"},{"title":"Bezier Patches","route":"drawing/bezier-patches","path":"content/docs/microgl/patches.mdx"},{"title":"Lines","route":"drawing/lines","path":"content/docs/microgl/lines.mdx"},{"title":"Text","route":"drawing/text","path":"content/docs/microgl/text.mdx"},{"title":"Gradients","route":"drawing/gradients","path":"content/docs/microgl/gradients.mdx"},{"title":"More Samplers","route":"drawing/more-samplers","path":"content/docs/microgl/more-samplers.mdx"},{"title":"3D","route":"drawing/3d","path":"content/docs/microgl/draw-3d.mdx"}]}],"__map":{"getting-started/setup":"content/docs/microgl/setup.mdx","getting-started/features":"content/docs/microgl/features.mdx","concepts/numbers":"content/docs/microgl/numbers.mdx","concepts/math":"content/docs/microgl/math.mdx","concepts/rgba":"content/docs/microgl/rgba.mdx","concepts/pixel-coders":"content/docs/microgl/pixel-coders.mdx","concepts/samplers":"content/docs/microgl/samplers.mdx","concepts/composition":"content/docs/microgl/composition.mdx","concepts/bitmaps":"content/docs/microgl/bitmaps.mdx","concepts/3d":"content/docs/microgl/3d.mdx","concepts/canvas":"content/docs/microgl/canvas.mdx","drawing/rectangles":"content/docs/microgl/rectangles.mdx","drawing/rounded":"content/docs/microgl/rounded.mdx","drawing/quadrilaterals":"content/docs/microgl/quadrilaterals.mdx","drawing/triangle":"content/docs/microgl/triangle.mdx","drawing/triangle-batches":"content/docs/microgl/triangle-batches.mdx","drawing/polygons":"content/docs/microgl/polygons.mdx","drawing/masks":"content/docs/microgl/masks.mdx","drawing/path-fills":"content/docs/microgl/path-fills.mdx","drawing/path-stroke":"content/docs/microgl/path-stroke.mdx","drawing/bezier-patches":"content/docs/microgl/patches.mdx","drawing/lines":"content/docs/microgl/lines.mdx","drawing/text":"content/docs/microgl/text.mdx","drawing/gradients":"content/docs/microgl/gradients.mdx","drawing/more-samplers":"content/docs/microgl/more-samplers.mdx","drawing/3d":"content/docs/microgl/draw-3d.mdx"}}}},"__N_SSG":true}