{"pageProps":{"data":{"slug":"algorithms/planar-subdivision","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    li: \"li\",\n    code: \"code\",\n    h3: \"h3\",\n    em: \"em\",\n    h2: \"h2\",\n    blockquote: \"blockquote\",\n    br: \"br\",\n    pre: \"pre\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Introduction\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"Planarize Division\"\n      }), \" Tessellates any collection of polygons of any type\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Supports \", _jsx(_components.strong, {\n          children: \"Fill Rules\"\n        }), \" - \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"even-odd\"\n          })\n        }), \" and \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"non-zero\"\n          })\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Numerically stable\"\n        }), \". Can tessellate with any number \", _jsx(_components.strong, {\n          children: \"precision\"\n        }), \": \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"Q\"\n          })\n        }), \" (fixed point), \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"float\"\n          })\n        }), \" and \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"double\"\n          })\n        })]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Includes geometric optimizations\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Allocator-aware\"\n        }), \" so you can use it in any computer memory model\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"3\"\n        }), \" Configurable tessellation \", _jsx(_components.strong, {\n          children: \"qualities\"\n        })]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Debuggable messages flag with macro definition (this will require stdlib)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Debuggable optional approximate trapezes output\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Optional boundary info output\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"If randomization is incorporated at the algorithm edge-wise, this is the fastest algorithm on\\naverage with \", _jsx(_components.code, {\n          children: \"O(n*log(n))\"\n        }), \" performance for any type of polygons and multi-polygons. Currently, the\\nper edge randomization was disabled because it might make the implementation less stable, but I might\\nre-add it with a flag. Also, partial randomization can be accomplished by randomizing the polygon.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Fill Rules\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"These can be chosen by the Enum \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"microtess::fill_rule\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"fill_rule::non_zero\"\n          })\n        }), \" - only includes subdivisions, which have a non-zero winding number.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"fill_rule::even_odd\"\n          })\n        }), \" - only includes subdivisions, which have odd winding number.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Tessellation Quality\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"These can be chosen by the Enum \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"microtess::tess_quality\"\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"tess_quality::fine\"\n          })\n        }), \" - The fastest algorithm, but may produce zero area triangles on the\\nboundary because it fan triangulates the approximate trapezes. might be a problem if you are using SDF based AA\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"tess_quality::better\"\n          })\n        }), \" - A bit slower and might be susceptible for other issues, but produces\\ntriangles out of each trapeze in a way similar to ear clipping, this\\nfights zero area triangles on the boundary, so you can use SDF AA\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"tess_quality::prettier_with_extra_vertices\"\n          })\n        }), \" - fast algorithm, that produces eye pleasing results,\\nbut uses around x2 memory for indices because it adds a center vertex in a trapeze and therefore adds\\ntwo more triangles per trapeze on average\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"tess_quality::worst_visuals_but_fast_and_constant_memory\"\n          })\n        }), \" (TBD) - the worst algorithm visually, as it will\\ncreate 2 triangles per trapeze, BUT let's not forget each trapeze is an approximation, therefore cracks will\\nshow up in many cases. Also, this will have 2 triangles per trapeze so this is the most memory efficient\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Input\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Input to the algorithm is\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Fill rule enum \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"microtess::fill_rule\"\n          })\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Tess quality enum \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"microtess::tess_quality\"\n          })\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Any iterable container which stores collections of collections of vertices, Each collection is a single polygon,\\nand you can have as many as you want. In this example, I use my brewed container \", _jsx(_components.code, {\n          children: \"chunker\"\n        }), \", but you can\\nuse any standard one like a vector of vectors of vertices (\", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"std::vector<vector<vec2<number_type>>>\"\n          })\n        }), \").\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Output variables to be filled by the algorithm\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Optional \", _jsx(_components.strong, {\n          children: \"allocator\"\n        }), \" for computation\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Output\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The algorithm output in the example below:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Will fill The \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"output_triangles_type\"\n          })\n        }), \" for you to know how to iterate the triangles (\", _jsx(_components.em, {\n          children: \"TRIANGLES/FAN/STRIP\"\n        }), \")\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Will fill the user supplied \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"output_vertices\"\n          })\n        }), \" container with triangulation vertices.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Will fill the user supplied \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"output_indices\"\n          })\n        }), \" container with triangulation indices.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Will (\", _jsx(_components.strong, {\n          children: \"optionally\"\n        }), \") fill the user supplied \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"output_boundary_info\"\n          })\n        }), \" container for you to know how to identify the boundary.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Will (\", _jsx(_components.strong, {\n          children: \"optionally\"\n        }), \") fill the user supplied \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"output_optional_approximate_trapezes\"\n          })\n        }), \" container for you to roughly understand the trapezes.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Debugging\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If you are seeing bugs with the tessellation, try the following\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Set \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"APPLY_MERGE\"\n          })\n        }), \" template argument to \", _jsx(_components.code, {\n          children: \"false\"\n        }), \", this optimization might be producing problems.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Try increasing \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"MAX_ITERATIONS\"\n          })\n        }), \" template argument. Your algorithm might need more iterations if\\none of your polygons is huge. This argument is a fail safe way to exit an infinite loop if one shoudl occur.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Add \", _jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"#define MICROTESS_PLANAR_DEBUG_MESSAGES\"\n          })\n        }), \" before all other includes. This should give messages and throw\\nexceptions when the algorithm 'feels' things are wrong, so this can give you info.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Try increasing the precision of the \", _jsx(_components.code, {\n          children: \"number\"\n        }), \" type of the vertices:\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"If using \", _jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"Q\"\n              })\n            }), \", try increasing precision bits. \", _jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"Q<8> -> Q<15>\"\n              })\n            })]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"If using \", _jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"float\"\n              })\n            }), \", then try \", _jsx(_components.strong, {\n              children: _jsx(_components.code, {\n                children: \"double\"\n              })\n            }), \" etc..\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Example\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"taken from \", _jsx(_components.code, {\n          children: \"examples/example_geometry_complex_to_planar_subdivision.cpp\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      style: {\n        margin: \"auto\"\n      },\n      children: _jsx(\"img\", {\n        src: \"/images/tess/planar-sub-1.png\",\n        style: {\n          height: \"250px\",\n          margin: \"auto\"\n        }\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The example demonstrates usage of different linear containers (including the packaged non standard \", _jsx(_components.code, {\n        children: \"dynamic_array\"\n      }), \").\", _jsx(_components.br, {}), \"\\n\", \"The example also demonstrates different number types such as fixed point integer(\", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"Q\"\n        })\n      }), \" numbers), float and doubles.\", _jsx(_components.br, {}), \"\\n\", \"Tessellation computation is only \", _jsx(_components.strong, {\n        children: \"16\"\n      }), \" lines of code.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I use the \", _jsx(_components.strong, {\n        children: _jsx(_components.code, {\n          children: \"microgl\"\n        })\n      }), \" project to render the tessellation.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Tessellation is happening at lines \", _jsx(_components.code, {\n        children: \"#45\"\n      }), \"-\", _jsx(_components.code, {\n        children: \"#65\"\n      })]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp&lines=45-65\",\n        children: \"#define MICROGL_USE_EXTERNAL_MICRO_TESS\\n#include \\\"src/example.h\\\"\\n#include <microgl/canvas.h>\\n#include <microgl/bitmaps/bitmap.h>\\n#include <microgl/pixel_coders/RGB888_PACKED_32.h>\\n#include <microgl/samplers/flat_color.h>\\n#include <microgl/math/Q.h>\\n\\n#include <micro-tess/planarize_division.h>\\n#include <micro-tess/static_array.h>\\n#include <micro-tess/dynamic_array.h>\\n#include <micro-tess/chunker.h>\\n#include <micro-tess/std_rebind_allocator.h>\\n#include <vector>\\n\\ntemplate<typename item>\\nusing fixed_static_array = static_array<item, 10000>;\\n\\n// containers for collections of points (polygons) \\ntemplate<typename number>\\nusing chunker_t = allocator_aware_chunker<vertex2<number>, dynamic_array>;\\n//using chunker_t = allocator_aware_chunker<vertex2<number>, std::vector>;\\n//using chunker_t = non_allocator_aware_chunker<vertex2<number>, fixed_static_array>;\\n\\n// containers templates for output containers\\ntemplate<typename item>\\nusing container = dynamic_array<item>;\\n//using container = std::vector<item>;\\n//using container = static_array<item, 10000>;\\n\\ntemplate <typename number>\\ncontainer<vertex2<number>> box(float left, float top, float right,\\n                               float bottom, bool ccw=false) {\\n    using il = std::initializer_list<vertex2<number>>;\\n    if(!ccw)\\n        return il{{left,top}, {right,top}, {right,bottom}, {left,bottom}};\\n    return il{{left,top}, {left,bottom}, {right,bottom}, {right,top}};\\n};\\n\\ntemplate <typename number>\\nchunker_t<number> poly_inter_star_2() {\\n    using il = std::initializer_list<vertex2<number>>;\\n    chunker_t<number> A;\\n\\n    A.push_back_and_cut(il{{150, 150}, {450,150},\\n                            {200,450}, {300,50},\\n                            {400,450}});\\n\\n    A.push_back_and_cut(il{{150/2, 150/2}, {450/2,150/2},\\n                            {200/2,450/2}, {300/2,50/2},\\n                            {400/2,450/2}});\\n\\n    A.push_back_and_cut(il{{150/10, 150/10}, {450/10,150/10},\\n                            {200/10,450/10}, {300/10,50/10},\\n                            {400/10,450/10}});\\n\\n    A.push_back_and_cut(box<number>(50,50,300,300, false));\\n    A.push_back_and_cut(box<number>(50,250,600,300, true));\\n    A.push_back_and_cut(box<number>(50,450,100,500, true));\\n\\n    return A;\\n}\\n\\nint main() {\\n    using number = float;\\n    // using number = double;\\n    // using number = Q<2>;\\n    // using number = Q<4>;\\n    // using number = Q<8>;\\n    // using number = Q<12>;\\n    // using number = Q<15>;\\n    // using number = Q<16>;\\n\\n    // microgl drawing setup START\\n    using Canvas24= canvas<bitmap<RGB888_PACKED_32>>;\\n    sampling::flat_color<> color_red {{255, 0, 255, 255}};\\n    Canvas24 canvas(640, 480);\\n    // microgl drawing setup END\\n\\n    auto render_polygon = [&](const chunker_t<number> & pieces) {\\n        using index = unsigned int;\\n\\n        // Algorithm START\\n        // output tess vertices\\n        container<vertex2<number>> output_vertices;\\n        // output tess indices\\n        container<index> output_indices;\\n        // output optional approximate trapezes\\n        container<vertex2<number>> output_optional_approximate_trapezes;\\n        // output optional boundary info\\n        container<microtess::triangles::boundary_info> output_boundary;\\n        // output triangles indices type\\n        microtess::triangles::indices output_triangles_type;\\n        // optional computation allocator\\n        microtess::std_rebind_allocator<> allocator;\\n        // define algorithm\\n        using psd = microtess::planarize_division<\\n                            number,\\n                            decltype(output_vertices),\\n                            decltype(output_indices),\\n                            decltype(output_boundary)>;\\n                            decltype(allocator)>;\\n        // compute algorithm\\n        psd::template compute<decltype(pieces)>(pieces,\\n                        microtess::fill_rule::even_odd,\\n                        microtess::tess_quality::better,\\n                        output_vertices, \\n                        output_triangles_type, \\n                        output_indices,\\n                        &output_boundary, \\n                        &output_optional_approximate_trapezes,\\n                        allocator);\\n        // Algorithm END\\n\\n        canvas.clear({255, 255, 255, 255});\\n        canvas.drawTriangles<blendmode::Normal, porterduff::None<>, false>(\\n                color_red,\\n                matrix_3x3<number>::identity(),\\n                output_vertices.data(),\\n                (vertex2<number> *)nullptr,\\n                output_indices.data(),\\n                output_boundary.data(),\\n                output_indices.size(),\\n                output_triangles_type,\\n                255);\\n\\n        canvas.drawTrianglesWireframe({0,0,0,255},\\n                            matrix_3x3<number>::identity(),\\n                            output_vertices.data(),\\n                            output_indices.data(),\\n                            output_indices.size(),\\n                            output_triangles_type,\\n                            40);\\n\\n        for (index ix = 0; ix < output_optional_approximate_trapezes.size(); ix+=4)\\n            canvas.drawWuLinePath({0, 0, 0, 255},\\n                                  &output_optional_approximate_trapezes[ix], 4, true);\\n    };\\n\\n    auto render = [&](void*, void*, void*) -> void {\\n        static auto polygons = poly_inter_star_2<number>();\\n        render_polygon(polygons);\\n    };\\n\\n    example_run(&canvas, render);\\n}\\n\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"frontMatter":{},"document":{"name":"docs","groups":[{"title":"Getting Started","items":[{"title":"Setup","route":"getting-started/setup","path":"content/docs/micro-tess/setup.mdx"},{"title":"Features","route":"getting-started/features","path":"content/docs/micro-tess/features.mdx"}]},{"title":"Concepts","items":[{"title":"Numbers","route":"concepts/numbers","path":"content/docs/micro-tess/numbers.mdx"},{"title":"Triangles","route":"concepts/triangles","path":"content/docs/micro-tess/triangles.mdx"}]},{"title":"Algorithms","items":[{"title":"Path Fill","route":"algorithms/path-fill","path":"content/docs/micro-tess/path-fill.mdx"},{"title":"Path Stroke","route":"algorithms/path-stroke","path":"content/docs/micro-tess/path-stroke.mdx"},{"title":"Planar Subdivision","route":"algorithms/planar-subdivision","path":"content/docs/micro-tess/planar-subdivision.mdx"},{"title":"Stroke Tessellation","route":"algorithms/stroke","path":"content/docs/micro-tess/stroke.mdx"},{"title":"Ear Clipping Triangulation","route":"algorithms/ear-clipping","path":"content/docs/micro-tess/ear-clipping.mdx"},{"title":"Monotone Triangulation","route":"algorithms/monotone","path":"content/docs/micro-tess/monotone.mdx"},{"title":"Fan Triangulation","route":"algorithms/fan","path":"content/docs/micro-tess/fan.mdx"},{"title":"Bezier Curve Divider","route":"algorithms/bezier-curve-divider","path":"content/docs/micro-tess/bezier-curve-divider.mdx"},{"title":"Elliptic Arc Divider","route":"algorithms/elliptic-arc-divider","path":"content/docs/micro-tess/elliptic-arc-divider.mdx"},{"title":"Bezier Patch","route":"algorithms/bezier-patch","path":"content/docs/micro-tess/bezier-patch.mdx"}]}],"__map":{"getting-started/setup":"content/docs/micro-tess/setup.mdx","getting-started/features":"content/docs/micro-tess/features.mdx","concepts/numbers":"content/docs/micro-tess/numbers.mdx","concepts/triangles":"content/docs/micro-tess/triangles.mdx","algorithms/path-fill":"content/docs/micro-tess/path-fill.mdx","algorithms/path-stroke":"content/docs/micro-tess/path-stroke.mdx","algorithms/planar-subdivision":"content/docs/micro-tess/planar-subdivision.mdx","algorithms/stroke":"content/docs/micro-tess/stroke.mdx","algorithms/ear-clipping":"content/docs/micro-tess/ear-clipping.mdx","algorithms/monotone":"content/docs/micro-tess/monotone.mdx","algorithms/fan":"content/docs/micro-tess/fan.mdx","algorithms/bezier-curve-divider":"content/docs/micro-tess/bezier-curve-divider.mdx","algorithms/elliptic-arc-divider":"content/docs/micro-tess/elliptic-arc-divider.mdx","algorithms/bezier-patch":"content/docs/micro-tess/bezier-patch.mdx"}}}},"__N_SSG":true}