{"pageProps":{"data":{"slug":"concepts/triangles","content":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Introduction\"), mdx(\"p\", null, \"All algorithms in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"micro{tess}\")), \" have two types of output:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Triangles tessellation\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Arc dividing\")), mdx(\"h2\", null, \"Triangles\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Look at \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"<microtess/triangles.h>\")))), mdx(\"p\", null, \"Triangulation is essentially just a set of triangles, that can be happily rendered using well\\nknown rasterization algorithms, they are used everywhere because of it.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"In order to define a single triangle, we just need three points, but in order to define a\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"batch of triangles we need more than that:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A list of points \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Additional list of indices, that point to vertices' list\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A strategy to help us interpret how to fetch triangles\")), mdx(\"h3\", null, \"Indices types\"), mdx(\"p\", null, \"There are three major strategies to interpret the list of indices defined by\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"microtess::triangles::indices\"), \" enum at the file \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"<microtess/triangles.h>\"), \"  \"), mdx(\"img\", {\n    src: \"/images/tess/triangles.gif\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h3\", null, \"1. \", mdx(\"strong\", {\n    parentName: \"h3\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"indices::TRIANGLES\"))), mdx(\"p\", null, \"This is the simplest, every 3 consecutive indices define a triangle, for example:\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"Suppose list of indices is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"[0,1,2,3,4,5,6,7,8,9,10,11]\")), \", then there are 4 triangles.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"First triangle has indices \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"[0, 1, 2]\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Second triangle has indices \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"[3, 4, 5]\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Third triangle has indices \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"[6, 7, 8]\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"And so on\")), mdx(\"h4\", null, mdx(\"strong\", {\n    parentName: \"h4\"\n  }, \"Advanatages\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This method is very intuitive.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Can encode any batch of triangles.\")), mdx(\"h4\", null, mdx(\"strong\", {\n    parentName: \"h4\"\n  }, \"Disadvanatages\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Consumes the most memory. If we have \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"n\")), \" triangles, then we will need \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"3*n\")), \" indices to encode them.\")), mdx(\"h3\", null, \"2. \", mdx(\"strong\", {\n    parentName: \"h3\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"indices::TRIANGLES_FAN\"))), mdx(\"p\", null, \"This one is the simple as well. We pick a base index (usually the first) and then pick every\\nconsecutive 2 indices.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"Suppose list of indices is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"[0,1,2,3,4,5,6,7,8,9,10,11,12]\")), \", then there are 6 triangles.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"First triangle has indices \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"[0, 1, 2]\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Second triangle has indices \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"[0, 2, 3]\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Third triangle has indices \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"[0, 4, 5]\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"And so on\")), mdx(\"h4\", null, mdx(\"strong\", {\n    parentName: \"h4\"\n  }, \"Advanatages\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This method is intuitive. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It is easy on memory. If we have \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"n\")), \" triangles, then we will need\", mdx(\"br\", {\n    parentName: \"li\"\n  }), mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"2*n + 1\")), \" indices. Much better than \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"indices::TRIANGLES\")), \"  \")), mdx(\"h4\", null, mdx(\"strong\", {\n    parentName: \"h4\"\n  }, \"Disadvanatages\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Cannot encode all triangle batches with it.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"May produce silver triangles\")), mdx(\"h3\", null, \"3. \", mdx(\"strong\", {\n    parentName: \"h3\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"indices::TRIANGLES_STRIP\"))), mdx(\"p\", null, \"This one is the hardest. Every group of 3 adjacent vertices forms a triangle. The face direction of the\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"strip is determined by the winding of the first triangle. Each successive triangle will have its effective\\nface order reversed, so the system compensates for that by testing it in the opposite way.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"Suppose list of indices is \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"[0,1,2,3,4,5,6,7,8,9,10,11,12]\")), \", then there are 6 triangles.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"First triangle has indices \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"[0, 1, 2]\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Second triangle has indices \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"[3, 2, 1]\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Third triangle has indices \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"[2, 3, 4]\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"And so on\")), mdx(\"h4\", null, mdx(\"strong\", {\n    parentName: \"h4\"\n  }, \"Advanatages\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It is the best on memory. If we have \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"n\")), \" triangles, then we will need\", mdx(\"br\", {\n    parentName: \"li\"\n  }), mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"n + 2\")), \" indices.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Can encode any batch with this method using degenerate triangles trick.\")), mdx(\"h4\", null, mdx(\"strong\", {\n    parentName: \"h4\"\n  }, \"Disadvanatages\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This method is not intuitive. \")), mdx(\"h2\", null, \"Triangles Iteration\"), mdx(\"p\", null, \"One can easily iterate triangles encoded in an indices list using the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"microtess::triangles::iterate_triangles\")), \" method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"/**\\n  * Iterate triangles encoded in a list of indices\\n  * @tparam iterator_callback a callback struct or lambda\\n  * @param indices pointer to indices array\\n  * @param size size of indices list\\n  * @param type the type of triangles\\n  * @param callback the callback instance\\n  */\\ntemplate<typename iterator_callback>\\nvoid iterate_triangles(const index *indices,\\n                       const index &size,\\n                       const enum triangles::indices &type,\\n                       const iterator_callback & callback);\\n\\n\")), mdx(\"h4\", null, \"Example\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"using index = unsigned int;\\nindex indices[6] {0, 1, 2, 3, 4, 5};\\n\\niterate_triangles(indices, 6, indices::TRIANGLES,\\n      [&](const index triangle_index, \\n          const index first_index, const index second_index, const index third_index,\\n          const index edge_0_id, const index edge_1_id, const index edge_2_id) {\\n            std::cout << 'outputing triangle #' << triangle_index << std::endl\\n                      << 'triangle is (' << first_index << '-' << second_index << '-'\\n                      << third_index << ')' << std::endl;\\n          }\\n\")), mdx(\"p\", null, \"If you don't like lambdas, you can implement a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"struct\"), \" that implements the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"operator()\")));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<h1 class=\"css-0\">Introduction</h1><p class=\"css-0\">All algorithms in <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css gy3xy5\">.css-gy3xy5{color:pink.600;display:inline;}</style><div class=\"css-gy3xy5\">micro{tess}</div></strong> have two types of output:</p><ol class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">Triangles tessellation</li><li class=\"css-b0qdn7\">Arc dividing</li></ol><h2 class=\"css-0\">Triangles</h2><style data-emotion=\"css 1rh9a91\">.css-1rh9a91{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:pink.400;}</style><blockquote class=\"css-1rh9a91\"><p class=\"css-0\">Look at <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css gy3xy5\">.css-gy3xy5{color:pink.600;display:inline;}</style><div class=\"css-gy3xy5\">&lt;microtess/triangles.h&gt;</div></strong></p></blockquote><p class=\"css-0\">Triangulation is essentially just a set of triangles, that can be happily rendered using well\nknown rasterization algorithms, they are used everywhere because of it.<div class=\"css-0\"></div>\n<!-- -->In order to define a single triangle, we just need three points, but in order to define a<div class=\"css-0\"></div>\n<!-- -->batch of triangles we need more than that:</p><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">A list of points </li><li class=\"css-b0qdn7\">Additional list of indices, that point to vertices&#x27; list</li><li class=\"css-b0qdn7\">A strategy to help us interpret how to fetch triangles</li></ul><h3 class=\"css-0\">Indices types</h3><p class=\"css-0\">There are three major strategies to interpret the list of indices defined by<div class=\"css-0\"></div>\n<style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">microtess::triangles::indices</strong> enum at the file <strong class=\"css-10ircq3\">&lt;microtess/triangles.h&gt;</strong>  </p><img src=\"/images/tess/triangles.gif\" style=\"height:250px;margin:auto\"/><h3 class=\"css-0\">1. <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css gy3xy5\">.css-gy3xy5{color:pink.600;display:inline;}</style><div class=\"css-gy3xy5\">indices::TRIANGLES</div></strong></h3><p class=\"css-0\">This is the simplest, every 3 consecutive indices define a triangle, for example:<div class=\"css-0\"></div>\n<!-- -->Suppose list of indices is <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css gy3xy5\">.css-gy3xy5{color:pink.600;display:inline;}</style><div class=\"css-gy3xy5\">[0,1,2,3,4,5,6,7,8,9,10,11]</div></strong>, then there are 4 triangles.</p><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">First triangle has indices <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css gy3xy5\">.css-gy3xy5{color:pink.600;display:inline;}</style><div class=\"css-gy3xy5\">[0, 1, 2]</div></strong></li><li class=\"css-b0qdn7\">Second triangle has indices <strong class=\"css-10ircq3\"><div class=\"css-gy3xy5\">[3, 4, 5]</div></strong></li><li class=\"css-b0qdn7\">Third triangle has indices <strong class=\"css-10ircq3\"><div class=\"css-gy3xy5\">[6, 7, 8]</div></strong></li><li class=\"css-b0qdn7\">And so on</li></ul><h4 class=\"css-0\"><style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">Advanatages</strong></h4><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">This method is very intuitive.</li><li class=\"css-b0qdn7\">Can encode any batch of triangles.</li></ul><h4 class=\"css-0\"><style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">Disadvanatages</strong></h4><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">Consumes the most memory. If we have <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css gy3xy5\">.css-gy3xy5{color:pink.600;display:inline;}</style><div class=\"css-gy3xy5\">n</div></strong> triangles, then we will need <strong class=\"css-10ircq3\"><div class=\"css-gy3xy5\">3*n</div></strong> indices to encode them.</li></ul><h3 class=\"css-0\">2. <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css gy3xy5\">.css-gy3xy5{color:pink.600;display:inline;}</style><div class=\"css-gy3xy5\">indices::TRIANGLES_FAN</div></strong></h3><p class=\"css-0\">This one is the simple as well. We pick a base index (usually the first) and then pick every\nconsecutive 2 indices.<div class=\"css-0\"></div>\n<!-- -->Suppose list of indices is <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css gy3xy5\">.css-gy3xy5{color:pink.600;display:inline;}</style><div class=\"css-gy3xy5\">[0,1,2,3,4,5,6,7,8,9,10,11,12]</div></strong>, then there are 6 triangles.</p><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">First triangle has indices <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css gy3xy5\">.css-gy3xy5{color:pink.600;display:inline;}</style><div class=\"css-gy3xy5\">[0, 1, 2]</div></strong></li><li class=\"css-b0qdn7\">Second triangle has indices <strong class=\"css-10ircq3\"><div class=\"css-gy3xy5\">[0, 2, 3]</div></strong></li><li class=\"css-b0qdn7\">Third triangle has indices <strong class=\"css-10ircq3\"><div class=\"css-gy3xy5\">[0, 4, 5]</div></strong></li><li class=\"css-b0qdn7\">And so on</li></ul><h4 class=\"css-0\"><style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">Advanatages</strong></h4><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">This method is intuitive. </li><li class=\"css-b0qdn7\">It is easy on memory. If we have <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css gy3xy5\">.css-gy3xy5{color:pink.600;display:inline;}</style><div class=\"css-gy3xy5\">n</div></strong> triangles, then we will need<div class=\"css-0\"></div><strong class=\"css-10ircq3\"><div class=\"css-gy3xy5\">2*n + 1</div></strong> indices. Much better than <strong class=\"css-10ircq3\"><div class=\"css-gy3xy5\">indices::TRIANGLES</div></strong>  </li></ul><h4 class=\"css-0\"><style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">Disadvanatages</strong></h4><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">Cannot encode all triangle batches with it.</li><li class=\"css-b0qdn7\">May produce silver triangles</li></ul><h3 class=\"css-0\">3. <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css gy3xy5\">.css-gy3xy5{color:pink.600;display:inline;}</style><div class=\"css-gy3xy5\">indices::TRIANGLES_STRIP</div></strong></h3><p class=\"css-0\">This one is the hardest. Every group of 3 adjacent vertices forms a triangle. The face direction of the<div class=\"css-0\"></div>\n<!-- -->strip is determined by the winding of the first triangle. Each successive triangle will have its effective\nface order reversed, so the system compensates for that by testing it in the opposite way.<div class=\"css-0\"></div>\n<!-- -->Suppose list of indices is <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css gy3xy5\">.css-gy3xy5{color:pink.600;display:inline;}</style><div class=\"css-gy3xy5\">[0,1,2,3,4,5,6,7,8,9,10,11,12]</div></strong>, then there are 6 triangles.</p><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">First triangle has indices <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css gy3xy5\">.css-gy3xy5{color:pink.600;display:inline;}</style><div class=\"css-gy3xy5\">[0, 1, 2]</div></strong></li><li class=\"css-b0qdn7\">Second triangle has indices <strong class=\"css-10ircq3\"><div class=\"css-gy3xy5\">[3, 2, 1]</div></strong></li><li class=\"css-b0qdn7\">Third triangle has indices <strong class=\"css-10ircq3\"><div class=\"css-gy3xy5\">[2, 3, 4]</div></strong></li><li class=\"css-b0qdn7\">And so on</li></ul><h4 class=\"css-0\"><style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">Advanatages</strong></h4><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">It is the best on memory. If we have <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css gy3xy5\">.css-gy3xy5{color:pink.600;display:inline;}</style><div class=\"css-gy3xy5\">n</div></strong> triangles, then we will need<div class=\"css-0\"></div><strong class=\"css-10ircq3\"><div class=\"css-gy3xy5\">n + 2</div></strong> indices.</li><li class=\"css-b0qdn7\">Can encode any batch with this method using degenerate triangles trick.</li></ul><h4 class=\"css-0\"><style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">Disadvanatages</strong></h4><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">This method is not intuitive. </li></ul><h2 class=\"css-0\">Triangles Iteration</h2><p class=\"css-0\">One can easily iterate triangles encoded in an indices list using the <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css gy3xy5\">.css-gy3xy5{color:pink.600;display:inline;}</style><div class=\"css-gy3xy5\">microtess::triangles::iterate_triangles</div></strong> method.</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-c\" style=\"white-space:pre\"><span style=\"color:#B6B18B\">/**\n</span><span style=\"color:#B6B18B\">  * Iterate triangles encoded in a list of indices\n</span><span style=\"color:#B6B18B\">  * @tparam iterator_callback a callback struct or lambda\n</span><span style=\"color:#B6B18B\">  * @param indices pointer to indices array\n</span><span style=\"color:#B6B18B\">  * @param size size of indices list\n</span><span style=\"color:#B6B18B\">  * @param type the type of triangles\n</span><span style=\"color:#B6B18B\">  * @param callback the callback instance\n</span><span style=\"color:#B6B18B\">  */</span><span>\n</span><span></span><span class=\"hljs-function\" style=\"color:#B45EA4\">template</span><span class=\"hljs-function\">&lt;</span><span class=\"hljs-function\" style=\"color:#B45EA4\">typename</span><span class=\"hljs-function\"> iterator_callback&gt;\n</span><span class=\"hljs-function\"></span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">iterate_triangles</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> index *indices,\n</span><span class=\"hljs-function\" style=\"color:#E7CE56\">                       </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> index &amp;size,\n</span><span class=\"hljs-function\" style=\"color:#E7CE56\">                       </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">enum</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> triangles::indices &amp;type,\n</span><span class=\"hljs-function\" style=\"color:#E7CE56\">                       </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> iterator_callback &amp; callback)</span><span>;\n</span>\n<!-- -->\n</code></pre></pre><h4 class=\"css-0\">Example</h4><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-c\" style=\"white-space:pre\"><span style=\"color:#B45EA4\">using</span><span> index = </span><span style=\"color:#B45EA4\">unsigned</span><span> </span><span style=\"color:#B45EA4\">int</span><span>;\n</span><span>index indices[</span><span style=\"color:#E7CE56\">6</span><span>] {</span><span style=\"color:#E7CE56\">0</span><span>, </span><span style=\"color:#E7CE56\">1</span><span>, </span><span style=\"color:#E7CE56\">2</span><span>, </span><span style=\"color:#E7CE56\">3</span><span>, </span><span style=\"color:#E7CE56\">4</span><span>, </span><span style=\"color:#E7CE56\">5</span><span>};\n</span>\n<span>iterate_triangles(indices, </span><span style=\"color:#E7CE56\">6</span><span>, indices::TRIANGLES,\n</span><span>      [&amp;](</span><span style=\"color:#B45EA4\">const</span><span> index triangle_index, \n</span><span>          </span><span style=\"color:#B45EA4\">const</span><span> index first_index, </span><span style=\"color:#B45EA4\">const</span><span> index second_index, </span><span style=\"color:#B45EA4\">const</span><span> index third_index,\n</span><span>          </span><span style=\"color:#B45EA4\">const</span><span> index edge_0_id, </span><span style=\"color:#B45EA4\">const</span><span> index edge_1_id, </span><span style=\"color:#B45EA4\">const</span><span> index edge_2_id) {\n</span><span>            </span><span style=\"color:#E7CE56\">std</span><span>::</span><span style=\"color:#E7CE56\">cout</span><span> &lt;&lt; </span><span style=\"color:#4FB4D7\">&#x27;outputing triangle #&#x27;</span><span> &lt;&lt; triangle_index &lt;&lt; </span><span style=\"color:#E7CE56\">std</span><span>::</span><span style=\"color:#E7CE56\">endl</span><span>\n</span><span>                      &lt;&lt; </span><span style=\"color:#4FB4D7\">&#x27;triangle is (&#x27;</span><span> &lt;&lt; first_index &lt;&lt; </span><span style=\"color:#4FB4D7\">&#x27;-&#x27;</span><span> &lt;&lt; second_index &lt;&lt; </span><span style=\"color:#4FB4D7\">&#x27;-&#x27;</span><span>\n</span><span>                      &lt;&lt; third_index &lt;&lt; </span><span style=\"color:#4FB4D7\">&#x27;)&#x27;</span><span> &lt;&lt; </span><span style=\"color:#E7CE56\">std</span><span>::</span><span style=\"color:#E7CE56\">endl</span><span>;\n</span>          }\n<!-- -->\n</code></pre></pre><p class=\"css-0\">If you don&#x27;t like lambdas, you can implement a <style data-emotion=\"css gy3xy5\">.css-gy3xy5{color:pink.600;display:inline;}</style><div class=\"css-gy3xy5\">struct</div> that implements the <div class=\"css-gy3xy5\">operator()</div></p>","scope":{}},"frontMatter":{},"document":{"name":"docs","groups":[{"title":"Getting Started","items":[{"title":"Setup","route":"getting-started/setup","path":"content/docs/micro-tess/setup.mdx"},{"title":"Features","route":"getting-started/features","path":"content/docs/micro-tess/features.mdx"}]},{"title":"Concepts","items":[{"title":"Numbers","route":"concepts/numbers","path":"content/docs/micro-tess/numbers.mdx"},{"title":"Triangles","route":"concepts/triangles","path":"content/docs/micro-tess/triangles.mdx"}]},{"title":"Algorithms","items":[{"title":"Path Fill","route":"algorithms/path-fill","path":"content/docs/micro-tess/path-fill.mdx"},{"title":"Path Stroke","route":"algorithms/path-stroke","path":"content/docs/micro-tess/path-stroke.mdx"},{"title":"Planar Subdivision","route":"algorithms/planar-subdivision","path":"content/docs/micro-tess/planar-subdivision.mdx"},{"title":"Stroke Tessellation","route":"algorithms/stroke","path":"content/docs/micro-tess/stroke.mdx"},{"title":"Ear Clipping Triangulation","route":"algorithms/ear-clipping","path":"content/docs/micro-tess/ear-clipping.mdx"},{"title":"Monotone Triangulation","route":"algorithms/monotone","path":"content/docs/micro-tess/monotone.mdx"},{"title":"Fan Triangulation","route":"algorithms/fan","path":"content/docs/micro-tess/fan.mdx"},{"title":"Bezier Curve Divider","route":"algorithms/bezier-curve-divider","path":"content/docs/micro-tess/bezier-curve-divider.mdx"},{"title":"Elliptic Arc Divider","route":"algorithms/elliptic-arc-divider","path":"content/docs/micro-tess/elliptic-arc-divider.mdx"},{"title":"Bezier Patch","route":"algorithms/bezier-patch","path":"content/docs/micro-tess/bezier-patch.mdx"}]}],"__map":{"getting-started/setup":"content/docs/micro-tess/setup.mdx","getting-started/features":"content/docs/micro-tess/features.mdx","concepts/numbers":"content/docs/micro-tess/numbers.mdx","concepts/triangles":"content/docs/micro-tess/triangles.mdx","algorithms/path-fill":"content/docs/micro-tess/path-fill.mdx","algorithms/path-stroke":"content/docs/micro-tess/path-stroke.mdx","algorithms/planar-subdivision":"content/docs/micro-tess/planar-subdivision.mdx","algorithms/stroke":"content/docs/micro-tess/stroke.mdx","algorithms/ear-clipping":"content/docs/micro-tess/ear-clipping.mdx","algorithms/monotone":"content/docs/micro-tess/monotone.mdx","algorithms/fan":"content/docs/micro-tess/fan.mdx","algorithms/bezier-curve-divider":"content/docs/micro-tess/bezier-curve-divider.mdx","algorithms/elliptic-arc-divider":"content/docs/micro-tess/elliptic-arc-divider.mdx","algorithms/bezier-patch":"content/docs/micro-tess/bezier-patch.mdx"}}}},"__N_SSG":true}