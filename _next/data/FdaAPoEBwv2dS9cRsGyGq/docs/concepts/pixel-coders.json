{"pageProps":{"data":{"slug":"concepts/pixel-coders","content":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Introduction\"), mdx(\"p\", null, \"Pixel coders are objects that can encode color or intensity into pixel representation\\nand also decode a pixel into a color.  \"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"microgl\"), \" can support any color configuration and any pixel format you can think of.\"), mdx(\"h1\", null, \"How to define pixel coder\"), mdx(\"h2\", null, \"1. Implement the basic interface\"), mdx(\"p\", null, \"at it's simplest form, you have to implement the following interface. the struct/class have to be\\n\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"default constructable\"), \".\\nhere is a basic pixel coder, that encodes \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"RGB\"), \" 8-bit color channels into a packed\\n32 bit integer. This is the minimal interface you have to implement to have a pixel coder.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"#include <microgl/rgba.h>\\n\\nstruct RGB888_PACKED_32 {\\n    using rgba = rgba_t<8, 8, 8, 0>; // rgba info\\n    using pixel = uint32_t; // pixel type\\n\\n    // these methods can be static if they do not access any variable\\n    // this encodes a color object into a pixel of type uint32_t\\n    inline void encode(const color_t &input, pixel &output) const {\\n        output = (input.r << 16) + (input.g << 8) + input.b;\\n    }\\n\\n    // this decodes a uint32_t integer into a color object\\n    inline void decode(const pixel &input, color_t &output) const {\\n        output.r = (input & 0x00FF0000) >> 16;\\n        output.g = (input & 0x0000FF00) >> 8;\\n        output.b = (input & 0x000000FF);\\n    }\\n\\n}\\n\")), mdx(\"h2\", null, \"2. instantiate the \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"RGBA_PACKED\"), \" template\"), mdx(\"p\", null, \"this template is a generic and simple way to define a pixel coder, that can be packed\\ninside the smallest fitting integer type. you can also define the ordering of the channels.\\nat it's simplest, the signature of the template is:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"// defined at <microgl/pixel_coders/RGBA_PACKED.h>\\ntemplate<u8 r, u8 g, u8 b, u8 a=0, u8 ri=0, u8 gi=1, u8 bi=2, u8 ai=3>\\nstruct RGBA_PACKED { \\n    // the rgba info is here\\n    using rgba = rgba_t<r, g, b, a>;\\n    // the pixel type is here\\n    using pixel = ... // will automatically be uint8_t, uint16_t, uint32_t, uint64_t\\n    ... \\n    ... \\n}\\n\")), mdx(\"p\", null, \"the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"r/g/b/a\"), \" template arguments are used to define the bit depth of the color channels.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"while the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ri/gi/bi/ai\"), \" template arguments are used to define the ordering of the channels\\nso you can be flexible about the layout. here is an example, you can use:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"#include <microgl/pixel_coders/RGBA_PACKED.h>\\n\\nusing RGB_565 = RGBA_PACKED<5, 6, 5, 0>;\\n\")), mdx(\"h2\", null, \"3. Instantiate the \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"RGBA_UNPACKED\"), \" template\"), mdx(\"p\", null, \"the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RGBA_UNPACKED\"), \" struct defines a trivial pixel coder, that encodes the color into an array,\\nthe array size is inferred at compile-time according to non-zero channels. it's signature\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"// defined at <microgl/pixel_coders/RGBA_PACKED.h>\\ntemplate<uint8_t r, uint8_t g, uint8_t b, uint8_t a, bool delete_zero_channel=true>\\nstruct RGBA_UNPACKED {\\n    using rgba = rgba_t<r,g,b,a>;\\n    using pixel = array<count> ;\\n    static constexpr uint8_t count;\\n    ...\\n    ...\\n}\\n\")), mdx(\"p\", null, \"you can use this coder simply with\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"#include <microgl/pixel_coders/RGBA_UNPACKED.h>\\n\\nusing RGB_888 = RGBA_UNPACKED<8, 8, 8, 0>;\\n// the inferred pixel type which is an array\\nusing pixel = typename RGB_888::pixel;\\npixel output;\\n// encode a color object into 8 bits array\\nRGB_888::encode({31, 63, 31}, output)\\n\\nuint8_t r = output.data[0];\\nuint8_t g = output.data[1];\\nuint8_t b = output.data[2];\\n// now let's decode\\ncolor_t decoded_color;\\nRGB_888::decode(output, decoded_color);\\n\\n\")), mdx(\"p\", null, \"using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RGBA_UNPACKED\"), \" can save memory if you have an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rgba=(8,8,8,0)\"), \", in which case\\nthey are better suited to be stored in a 3 element array rather than a packed a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uint32_t\"), \"\\ntype (using a packed \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uint32_t\"), \" will have a wasted byte).\"), mdx(\"h2\", null, \"4. extend the \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"pixel_coder\"), \" class\"), mdx(\"p\", null, \"you can also extend \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pixel_coder\"), \" class defined at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<microgl/pixel_coder.h>\"), \".\\nusing this can boost your pixel coder with extra utility methods, it uses compile-time\\ninheritance via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"crpt\"), \" design pattern, but it will cause your class to be less compact,\\nbecause of template issues.\"), mdx(\"h2\", null, \"5. use prebuilt pixel coders\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"out of the box, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"<microgl/pixel_coders>\"), \" is packed with the following pixel coders for your conveniance\")), mdx(\"h2\", null, \"True color coders (32 bit coders)\"), mdx(\"p\", null, \"for pixels stored in a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"4 bytes\"), \" data structure\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RGB888_PACKED_32.h\"), \" - \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"rgb(8|8|8)\"), \" channels into a 32 bit unsigned integer\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RGBA8888_PACKED_32.h\"), \" - \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"rgba(8|8|8|8)\"), \" channels into a 32 bit unsigned integer\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RGBA8888_ARRAY.h\"), \" - \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"rgba(8|8|8|8)\"), \" channels into array (faster io)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RGB888_ARRAY.h\"), \" - \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"rgb(8|8|8)\"), \" channels into array (faster io)\")), mdx(\"h2\", null, \"16 bit coders\"), mdx(\"p\", null, \"for pixels stored in a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"2 bytes\"), \" data structure\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RGB555_PACKED_16.h\"), \" - \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"rgb(5|5|5)\"), \" channels into a 16 bits unsigned integer (word)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RGB565_PACKED_16.h\"), \" - \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"rgb(5|6|5)\"), \" channels into a 16 bits unsigned integer (word)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RGBA4444_PACKED_16.h\"), \" - \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"rgba(4|4|4|4)\"), \" channels into a 16 bits unsigned integer (word)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RGBA5551_PACKED_16.h\"), \" - \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"rgba(5|5|5|1)\"), \" channels into a 16 bits unsigned integer (word)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ARGB1555_PACKED_16.h\"), \" - \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"argb(1|5|5|5)\"), \" channels into a 16 bits unsigned integer (word)\")), mdx(\"h2\", null, \"8 bit coders\"), mdx(\"p\", null, \"for pixels stored in a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"1 bytes\"), \" data structure\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RGB332_PACKED_8.h\"), \" - \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"rgb(3|3|2)\"), \" channels into a 8 bits unsigned integer (char)\")), mdx(\"h2\", null, \"Memory friendly coders\"), mdx(\"p\", null, \"the following coders are very handy for packed bitmaps, they also use a lookup table for\\nfast conversions\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"BPP_RGBA.h\")), \" - this will map/scale 1,2,4,8 bits pixel to a defined alpha channel bits, rgb values will stay\\nfixed on maximum value. Uses a single lookup table only if needed at compile time. Good for optimized bitmap fonts.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"BPP_RGB.h\"), \" - this will map 1,2,4,8 bits to predefined RGB channels bits, uses\\n3 lookup tables only if needed. Alpha channel is discarded.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"BPP_1_RGB.h\"), \" - 1 bit channel (2 colors) scaled into any rgb depth\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"BPP_2_RGB.h\"), \" - 2 bit channel (4 colors) scaled into any rgb depth\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"BPP_4_RGB.h\"), \" - 4 bit channel (16 colors) scaled into any rgb depth\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"BPP_8_RGB.h\"), \" - 8 bit channel (256 colors) scaled into any rgb depth\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"BPP_1_RGBA.h\"), \" - 1 bit channel (2 colors) scaled into any rgba depth\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"BPP_2_RGBA.h\"), \" - 2 bit channel (4 colors) scaled into any rgba depth\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"BPP_4_RGBA.h\"), \" - 4 bit channel (16 colors) scaled into any rgba depth\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"BPP_8_RGBA.h\"), \" - 8 bit channel (256 colors) scaled into any rgba depth\")), mdx(\"h2\", null, \"Special Coders\"), mdx(\"p\", null, \"this coders can transform a coder to another rgba depth\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"coder_rgba.h\"), \" - convert a given coder to a different rgba color depth\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"coder_converter.h\"), \" - convert one coder to the color depth of another coder\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"GRAYSCALE.h\"), \" - a pixel coder template, that saves one channel, also supports alpha channel\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SINGLE.h\"), \" - defines 4 single channel pixel coders structs \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"R\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"G\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"B\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"A\"), \" literaly\")), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"microgl::coder\"), \" namespace\"), mdx(\"h3\", null, \"encode intensity into a pixel with a pixel coder\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"/**\\n* encode intensity into a pixel with a pixel coder\\n*\\n* @tparam number underlying intensity number type\\n* @tparam Coder the pixel coder type to use\\n*\\n* @param input input intensity\\n* @param output output pixel\\n* @param $coder the coder reference\\n*/\\ntemplate <typename number, class Coder>\\nvoid inline\\nencode(const intensity<number> &input, typename Coder::pixel &output, const Coder & $coder)\\n\")), mdx(\"h3\", null, \"decode pixel into intensity using a coder\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"/**\\n* decode pixel into intensity using a coder\\n*\\n* @tparam number underlying intensity number type\\n* @tparam Coder the pixel coder type to use\\n*\\n* @param input input pixel\\n* @param output output intensity\\n* @param $coder the coder reference\\n*/\\ntemplate <typename number, class Coder>\\nvoid decode(const typename Coder::pixel &input, intensity<number> &output, const Coder & $coder) {\\n\")), mdx(\"h3\", null, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"pixel_coder\"), \" class\"), mdx(\"p\", null, \"a base pixel coder that can boost your pixel coder with extra utilities.\\ninheritance is via crpt design pattern.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"/**\\n*\\n* @tparam pixel_ the pixel storage type\\n* @tparam rgba_ the {rgba_t} info object\\n* @tparam impl the type of the derived class\\n*/\\ntemplate<typename pixel_, typename rgba_, typename impl>\\nclass pixel_coder : public crpt<impl> {\\n    using pixel= pixel_;\\n    using rgba= rgba_;\\n\\n    // this will encode in your derived class\\n    void encode(const color_t &input, pixel &output) const\\n    // this will decode in your derived class\\n    void decode(const pixel &input, color_t &output) const\\n\\n    /**\\n    * encode intensity to pixel of the coder\\n    *\\n    * @tparam number underlying intensity number type\\n    *\\n    * @param input input intensity\\n    * @param output output pixel\\n    */\\n    template <typename number>\\n    void encode(const intensity<number> &input, pixel &output) const\\n\\n    /**\\n    * decode pixel into intensity\\n    *\\n    * @tparam number underlying intensity number type\\n    *\\n    * @param input input pixel\\n    * @param output output intensity\\n    */\\n    template <typename number>\\n    void decode(const pixel &input, intensity<number> &output) const\\n\\n    /**\\n    * convert intensity to color of space defined but this coder\\n    *\\n    * @tparam number underlying intensity number type\\n    * @param input intensity\\n    * @param output color\\n    */\\n    template <typename number>\\n    void convert(const intensity<number> &input, color_t &output) const\\n\\n    /**\\n    * convert color to intensity\\n    *\\n    * @tparam number underlying intensity number type\\n    *\\n    * @param input color\\n    * @param output intensity\\n    */\\n    template <typename number>\\n    void convert(const color_t &input, intensity<number> &output) const\\n\\n    /**\\n    * convert a color of this coder space into a space of another coder\\n    *\\n    * @tparam CODER2 the other coder\\n    *\\n    * @param input color\\n    * @param output color output\\n    */\\n    template<typename CODER2>\\n    void convert(const color_t &input, color_t &output) const\\n    /**\\n    * convert a pixel from this coder to a pixel of another coder\\n    *\\n    * @tparam CODER2 the other coder\\n    *\\n    * @param input input pixel of my coder\\n    * @param output the output pixel\\n    * @param coder2 the other coder reference\\n    */\\n    template<typename CODER2>\\n    void convert(const pixel &input, typename CODER2::pixel &output, const CODER2 &coder2) const\\n\\n}\\n\")));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<h1 class=\"css-0\">Introduction</h1><p class=\"css-0\">Pixel coders are objects that can encode color or intensity into pixel representation\nand also decode a pixel into a color.  </p><p class=\"css-0\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">microgl</div> can support any color configuration and any pixel format you can think of.</p><h1 class=\"css-0\">How to define pixel coder</h1><h2 class=\"css-0\">1. Implement the basic interface</h2><p class=\"css-0\">at it&#x27;s simplest form, you have to implement the following interface. the struct/class have to be\n<style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">default constructable</strong>.\nhere is a basic pixel coder, that encodes <strong class=\"css-10ircq3\">RGB</strong> 8-bit color channels into a packed\n32 bit integer. This is the minimal interface you have to implement to have a pixel coder.</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#E7CE56\">#</span><span class=\"hljs-meta-keyword\" style=\"color:#E7CE56\">include</span><span style=\"color:#E7CE56\"> </span><span class=\"hljs-meta-string\" style=\"color:#E7CE56\">&lt;microgl/rgba.h&gt;</span><span>\n</span>\n<span></span><span class=\"hljs-class\" style=\"color:#B45EA4\">struct</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">RGB888_PACKED_32</span><span class=\"hljs-class\"> {</span><span>\n</span><span>    </span><span style=\"color:#B45EA4\">using</span><span> rgba = </span><span style=\"color:#B45EA4\">rgba_t</span><span>&lt;</span><span style=\"color:#E7CE56\">8</span><span>, </span><span style=\"color:#E7CE56\">8</span><span>, </span><span style=\"color:#E7CE56\">8</span><span>, </span><span style=\"color:#E7CE56\">0</span><span>&gt;; </span><span style=\"color:#B6B18B\">// rgba info</span><span>\n</span><span>    </span><span style=\"color:#B45EA4\">using</span><span> pixel = </span><span style=\"color:#B45EA4\">uint32_t</span><span>; </span><span style=\"color:#B6B18B\">// pixel type</span><span>\n</span>\n<span>    </span><span style=\"color:#B6B18B\">// these methods can be static if they do not access any variable</span><span>\n</span><span>    </span><span style=\"color:#B6B18B\">// this encodes a color object into a pixel of type uint32_t</span><span>\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">inline</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">encode</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp;input, pixel &amp;output)</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\"> </span><span>{\n</span><span>        output = (input.r &lt;&lt; </span><span style=\"color:#E7CE56\">16</span><span>) + (input.g &lt;&lt; </span><span style=\"color:#E7CE56\">8</span><span>) + input.b;\n</span>    }\n<!-- -->\n<span>    </span><span style=\"color:#B6B18B\">// this decodes a uint32_t integer into a color object</span><span>\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">inline</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">decode</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> pixel &amp;input, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp;output)</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\"> </span><span>{\n</span><span>        output.r = (input &amp; </span><span style=\"color:#E7CE56\">0x00FF0000</span><span>) &gt;&gt; </span><span style=\"color:#E7CE56\">16</span><span>;\n</span><span>        output.g = (input &amp; </span><span style=\"color:#E7CE56\">0x0000FF00</span><span>) &gt;&gt; </span><span style=\"color:#E7CE56\">8</span><span>;\n</span><span>        output.b = (input &amp; </span><span style=\"color:#E7CE56\">0x000000FF</span><span>);\n</span>    }\n<!-- -->\n<!-- -->}\n<!-- -->\n</code></pre></pre><h2 class=\"css-0\">2. instantiate the <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">RGBA_PACKED</div> template</h2><p class=\"css-0\">this template is a generic and simple way to define a pixel coder, that can be packed\ninside the smallest fitting integer type. you can also define the ordering of the channels.\nat it&#x27;s simplest, the signature of the template is:</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B6B18B\">// defined at &lt;microgl/pixel_coders/RGBA_PACKED.h&gt;</span><span>\n</span><span></span><span style=\"color:#B45EA4\">template</span><span>&lt;u8 r, u8 g, u8 b, u8 a=</span><span style=\"color:#E7CE56\">0</span><span>, u8 ri=</span><span style=\"color:#E7CE56\">0</span><span>, u8 gi=</span><span style=\"color:#E7CE56\">1</span><span>, u8 bi=</span><span style=\"color:#E7CE56\">2</span><span>, u8 ai=</span><span style=\"color:#E7CE56\">3</span><span>&gt;\n</span>struct RGBA_PACKED { \n<span>    </span><span style=\"color:#B6B18B\">// the rgba info is here</span><span>\n</span><span>    </span><span style=\"color:#B45EA4\">using</span><span> rgba = </span><span style=\"color:#B45EA4\">rgba_t</span><span>&lt;r, g, b, a&gt;;\n</span><span>    </span><span style=\"color:#B6B18B\">// the pixel type is here</span><span>\n</span><span>    </span><span style=\"color:#B45EA4\">using</span><span> pixel = ... </span><span style=\"color:#B6B18B\">// will automatically be uint8_t, uint16_t, uint32_t, uint64_t</span><span>\n</span>    ... \n<!-- -->    ... \n<!-- -->}\n<!-- -->\n</code></pre></pre><p class=\"css-0\">the <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">r/g/b/a</div> template arguments are used to define the bit depth of the color channels.<div class=\"css-0\"></div>\n<!-- -->while the <div class=\"css-qskmz3\">ri/gi/bi/ai</div> template arguments are used to define the ordering of the channels\nso you can be flexible about the layout. here is an example, you can use:</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#E7CE56\">#</span><span class=\"hljs-meta-keyword\" style=\"color:#E7CE56\">include</span><span style=\"color:#E7CE56\"> </span><span class=\"hljs-meta-string\" style=\"color:#E7CE56\">&lt;microgl/pixel_coders/RGBA_PACKED.h&gt;</span><span>\n</span>\n<span></span><span style=\"color:#B45EA4\">using</span><span> RGB_565 = RGBA_PACKED&lt;</span><span style=\"color:#E7CE56\">5</span><span>, </span><span style=\"color:#E7CE56\">6</span><span>, </span><span style=\"color:#E7CE56\">5</span><span>, </span><span style=\"color:#E7CE56\">0</span><span>&gt;;\n</span>\n</code></pre></pre><h2 class=\"css-0\">3. Instantiate the <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">RGBA_UNPACKED</div> template</h2><p class=\"css-0\">the <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">RGBA_UNPACKED</div> struct defines a trivial pixel coder, that encodes the color into an array,\nthe array size is inferred at compile-time according to non-zero channels. it&#x27;s signature</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B6B18B\">// defined at &lt;microgl/pixel_coders/RGBA_PACKED.h&gt;</span><span>\n</span><span></span><span style=\"color:#B45EA4\">template</span><span>&lt;</span><span style=\"color:#B45EA4\">uint8_t</span><span> r, </span><span style=\"color:#B45EA4\">uint8_t</span><span> g, </span><span style=\"color:#B45EA4\">uint8_t</span><span> b, </span><span style=\"color:#B45EA4\">uint8_t</span><span> a, </span><span style=\"color:#B45EA4\">bool</span><span> delete_zero_channel=</span><span style=\"color:#E7CE56\">true</span><span>&gt;\n</span>struct RGBA_UNPACKED {\n<span>    </span><span style=\"color:#B45EA4\">using</span><span> rgba = </span><span style=\"color:#B45EA4\">rgba_t</span><span>&lt;r,g,b,a&gt;;\n</span><span>    </span><span style=\"color:#B45EA4\">using</span><span> pixel = </span><span style=\"color:#E7CE56\">array</span><span>&lt;count&gt; ;\n</span><span>    </span><span style=\"color:#B45EA4\">static</span><span> </span><span style=\"color:#B45EA4\">constexpr</span><span> </span><span style=\"color:#B45EA4\">uint8_t</span><span> count;\n</span>    ...\n<!-- -->    ...\n<!-- -->}\n<!-- -->\n</code></pre></pre><p class=\"css-0\">you can use this coder simply with</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#E7CE56\">#</span><span class=\"hljs-meta-keyword\" style=\"color:#E7CE56\">include</span><span style=\"color:#E7CE56\"> </span><span class=\"hljs-meta-string\" style=\"color:#E7CE56\">&lt;microgl/pixel_coders/RGBA_UNPACKED.h&gt;</span><span>\n</span>\n<span></span><span style=\"color:#B45EA4\">using</span><span> RGB_888 = RGBA_UNPACKED&lt;</span><span style=\"color:#E7CE56\">8</span><span>, </span><span style=\"color:#E7CE56\">8</span><span>, </span><span style=\"color:#E7CE56\">8</span><span>, </span><span style=\"color:#E7CE56\">0</span><span>&gt;;\n</span><span></span><span style=\"color:#B6B18B\">// the inferred pixel type which is an array</span><span>\n</span><span></span><span style=\"color:#B45EA4\">using</span><span> pixel = </span><span style=\"color:#B45EA4\">typename</span><span> RGB_888::pixel;\n</span>pixel output;\n<span></span><span style=\"color:#B6B18B\">// encode a color object into 8 bits array</span><span>\n</span><span>RGB_888::encode({</span><span style=\"color:#E7CE56\">31</span><span>, </span><span style=\"color:#E7CE56\">63</span><span>, </span><span style=\"color:#E7CE56\">31</span><span>}, output)\n</span>\n<span></span><span style=\"color:#B45EA4\">uint8_t</span><span> r = output.data[</span><span style=\"color:#E7CE56\">0</span><span>];\n</span><span></span><span style=\"color:#B45EA4\">uint8_t</span><span> g = output.data[</span><span style=\"color:#E7CE56\">1</span><span>];\n</span><span></span><span style=\"color:#B45EA4\">uint8_t</span><span> b = output.data[</span><span style=\"color:#E7CE56\">2</span><span>];\n</span><span></span><span style=\"color:#B6B18B\">// now let&#x27;s decode</span><span>\n</span><span></span><span style=\"color:#B45EA4\">color_t</span><span> decoded_color;\n</span>RGB_888::decode(output, decoded_color);\n<!-- -->\n<!-- -->\n</code></pre></pre><p class=\"css-0\">using the <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">RGBA_UNPACKED</div> can save memory if you have an <div class=\"css-qskmz3\">rgba=(8,8,8,0)</div>, in which case\nthey are better suited to be stored in a 3 element array rather than a packed a <div class=\"css-qskmz3\">uint32_t</div>\ntype (using a packed <div class=\"css-qskmz3\">uint32_t</div> will have a wasted byte).</p><h2 class=\"css-0\">4. extend the <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">pixel_coder</div> class</h2><p class=\"css-0\">you can also extend <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">pixel_coder</div> class defined at <div class=\"css-qskmz3\">&lt;microgl/pixel_coder.h&gt;</div>.\nusing this can boost your pixel coder with extra utility methods, it uses compile-time\ninheritance via <div class=\"css-qskmz3\">crpt</div> design pattern, but it will cause your class to be less compact,\nbecause of template issues.</p><h2 class=\"css-0\">5. use prebuilt pixel coders</h2><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">out of the box, <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">&lt;microgl/pixel_coders&gt;</strong> is packed with the following pixel coders for your conveniance</p></blockquote><h2 class=\"css-0\">True color coders (32 bit coders)</h2><p class=\"css-0\">for pixels stored in a <em>4 bytes</em> data structure</p><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">RGB888_PACKED_32.h</div> - <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">rgb(8|8|8)</strong> channels into a 32 bit unsigned integer</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">RGBA8888_PACKED_32.h</div> - <strong class=\"css-10ircq3\">rgba(8|8|8|8)</strong> channels into a 32 bit unsigned integer</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">RGBA8888_ARRAY.h</div> - <strong class=\"css-10ircq3\">rgba(8|8|8|8)</strong> channels into array (faster io)</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">RGB888_ARRAY.h</div> - <strong class=\"css-10ircq3\">rgb(8|8|8)</strong> channels into array (faster io)</li></ul><h2 class=\"css-0\">16 bit coders</h2><p class=\"css-0\">for pixels stored in a <em>2 bytes</em> data structure</p><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">RGB555_PACKED_16.h</div> - <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">rgb(5|5|5)</strong> channels into a 16 bits unsigned integer (word)</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">RGB565_PACKED_16.h</div> - <strong class=\"css-10ircq3\">rgb(5|6|5)</strong> channels into a 16 bits unsigned integer (word)</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">RGBA4444_PACKED_16.h</div> - <strong class=\"css-10ircq3\">rgba(4|4|4|4)</strong> channels into a 16 bits unsigned integer (word)</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">RGBA5551_PACKED_16.h</div> - <strong class=\"css-10ircq3\">rgba(5|5|5|1)</strong> channels into a 16 bits unsigned integer (word)</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">ARGB1555_PACKED_16.h</div> - <strong class=\"css-10ircq3\">argb(1|5|5|5)</strong> channels into a 16 bits unsigned integer (word)</li></ul><h2 class=\"css-0\">8 bit coders</h2><p class=\"css-0\">for pixels stored in a <em>1 bytes</em> data structure</p><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">RGB332_PACKED_8.h</div> - <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">rgb(3|3|2)</strong> channels into a 8 bits unsigned integer (char)</li></ul><h2 class=\"css-0\">Memory friendly coders</h2><p class=\"css-0\">the following coders are very handy for packed bitmaps, they also use a lookup table for\nfast conversions</p><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\"><style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">BPP_RGBA.h</div></strong> - this will map/scale 1,2,4,8 bits pixel to a defined alpha channel bits, rgb values will stay\nfixed on maximum value. Uses a single lookup table only if needed at compile time. Good for optimized bitmap fonts.</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">BPP_RGB.h</div> - this will map 1,2,4,8 bits to predefined RGB channels bits, uses\n3 lookup tables only if needed. Alpha channel is discarded.</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">BPP_1_RGB.h</div> - 1 bit channel (2 colors) scaled into any rgb depth</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">BPP_2_RGB.h</div> - 2 bit channel (4 colors) scaled into any rgb depth</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">BPP_4_RGB.h</div> - 4 bit channel (16 colors) scaled into any rgb depth</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">BPP_8_RGB.h</div> - 8 bit channel (256 colors) scaled into any rgb depth</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">BPP_1_RGBA.h</div> - 1 bit channel (2 colors) scaled into any rgba depth</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">BPP_2_RGBA.h</div> - 2 bit channel (4 colors) scaled into any rgba depth</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">BPP_4_RGBA.h</div> - 4 bit channel (16 colors) scaled into any rgba depth</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">BPP_8_RGBA.h</div> - 8 bit channel (256 colors) scaled into any rgba depth</li></ul><h2 class=\"css-0\">Special Coders</h2><p class=\"css-0\">this coders can transform a coder to another rgba depth</p><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">coder_rgba.h</div> - convert a given coder to a different rgba color depth</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">coder_converter.h</div> - convert one coder to the color depth of another coder</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">GRAYSCALE.h</div> - a pixel coder template, that saves one channel, also supports alpha channel</li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">SINGLE.h</div> - defines 4 single channel pixel coders structs <div class=\"css-qskmz3\">R</div>, <div class=\"css-qskmz3\">G</div>, <div class=\"css-qskmz3\">B</div>, <div class=\"css-qskmz3\">A</div> literaly</li></ul><h2 class=\"css-0\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">microgl::coder</div> namespace</h2><h3 class=\"css-0\">encode intensity into a pixel with a pixel coder</h3><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\">* encode intensity into a pixel with a pixel coder\n</span><span class=\"hljs-function\">*\n</span><span class=\"hljs-function\">* @tparam number underlying intensity number type\n</span><span class=\"hljs-function\">* @tparam Coder the pixel coder type to use\n</span><span class=\"hljs-function\">*\n</span><span class=\"hljs-function\">* @param input input intensity\n</span><span class=\"hljs-function\">* @param output output pixel\n</span><span class=\"hljs-function\">* @param $coder the coder reference\n</span><span style=\"color:#B6B18B\">*/</span><span>\n</span><span></span><span style=\"color:#B45EA4\">template</span><span> &lt;</span><span style=\"color:#B45EA4\">typename</span><span> number, </span><span class=\"hljs-class\" style=\"color:#B45EA4\">class</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">Coder</span><span class=\"hljs-class\">&gt;</span><span>\n</span><span></span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">inline</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\"></span><span class=\"hljs-function\" style=\"color:#78BB65\">encode</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> intensity&lt;number&gt; &amp;input, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">typename</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> Coder::pixel &amp;output, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> Coder &amp; $coder)</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span></code></pre></pre><h3 class=\"css-0\">decode pixel into intensity using a coder</h3><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B6B18B\">/**\n</span><span style=\"color:#B6B18B\">* decode pixel into intensity using a coder\n</span><span style=\"color:#B6B18B\">*\n</span><span style=\"color:#B6B18B\">* @tparam number underlying intensity number type\n</span><span style=\"color:#B6B18B\">* @tparam Coder the pixel coder type to use\n</span><span style=\"color:#B6B18B\">*\n</span><span style=\"color:#B6B18B\">* @param input input pixel\n</span><span style=\"color:#B6B18B\">* @param output output intensity\n</span><span style=\"color:#B6B18B\">* @param $coder the coder reference\n</span><span style=\"color:#B6B18B\">*/</span><span>\n</span><span></span><span style=\"color:#B45EA4\">template</span><span> &lt;</span><span style=\"color:#B45EA4\">typename</span><span> number, </span><span class=\"hljs-class\" style=\"color:#B45EA4\">class</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">Coder</span><span class=\"hljs-class\">&gt;</span><span>\n</span><span></span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">decode</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">typename</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> Coder::pixel &amp;input, intensity&lt;number&gt; &amp;output, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> Coder &amp; $coder)</span><span class=\"hljs-function\"> </span><span>{\n</span>\n</code></pre></pre><h3 class=\"css-0\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">pixel_coder</div> class</h3><p class=\"css-0\">a base pixel coder that can boost your pixel coder with extra utilities.\ninheritance is via crpt design pattern.</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\">*\n</span><span class=\"hljs-function\">* @tparam pixel_ the pixel storage type\n</span><span class=\"hljs-function\">* @tparam rgba_ the {rgba_t} info object\n</span><span class=\"hljs-function\">* @tparam impl the type of the derived class\n</span><span style=\"color:#B6B18B\">*/</span><span>\n</span><span></span><span style=\"color:#B45EA4\">template</span><span>&lt;</span><span style=\"color:#B45EA4\">typename</span><span> pixel_, </span><span style=\"color:#B45EA4\">typename</span><span> rgba_, </span><span style=\"color:#B45EA4\">typename</span><span> impl&gt;\n</span><span></span><span class=\"hljs-class\" style=\"color:#B45EA4\">class</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">pixel_coder</span><span class=\"hljs-class\"> :</span><span> </span><span style=\"color:#B45EA4\">public</span><span> crpt&lt;impl&gt; {\n</span><span>    </span><span style=\"color:#B45EA4\">using</span><span> pixel= pixel_;\n</span><span>    </span><span style=\"color:#B45EA4\">using</span><span> rgba= rgba_;\n</span>\n<span>    </span><span style=\"color:#B6B18B\">// this will encode in your derived class</span><span>\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">encode</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp;input, pixel &amp;output)</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B6B18B\">// this will decode in your derived class</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">decode</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> pixel &amp;input, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp;output)</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\">    * encode intensity to pixel of the coder\n</span><span class=\"hljs-function\">    *\n</span><span class=\"hljs-function\">    * @tparam number underlying intensity number type\n</span><span class=\"hljs-function\">    *\n</span><span class=\"hljs-function\">    * @param input input intensity\n</span><span class=\"hljs-function\">    * @param output output pixel\n</span><span class=\"hljs-function\" style=\"color:#B6B18B\">    */</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">template</span><span class=\"hljs-function\"> &lt;</span><span class=\"hljs-function\" style=\"color:#B45EA4\">typename</span><span class=\"hljs-function\"> number&gt;\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">encode</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> intensity&lt;number&gt; &amp;input, pixel &amp;output)</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\">    * decode pixel into intensity\n</span><span class=\"hljs-function\">    *\n</span><span class=\"hljs-function\">    * @tparam number underlying intensity number type\n</span><span class=\"hljs-function\">    *\n</span><span class=\"hljs-function\">    * @param input input pixel\n</span><span class=\"hljs-function\">    * @param output output intensity\n</span><span class=\"hljs-function\" style=\"color:#B6B18B\">    */</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">template</span><span class=\"hljs-function\"> &lt;</span><span class=\"hljs-function\" style=\"color:#B45EA4\">typename</span><span class=\"hljs-function\"> number&gt;\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">decode</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> pixel &amp;input, intensity&lt;number&gt; &amp;output)</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\">    * convert intensity to color of space defined but this coder\n</span><span class=\"hljs-function\">    *\n</span><span class=\"hljs-function\">    * @tparam number underlying intensity number type\n</span><span class=\"hljs-function\">    * @param input intensity\n</span><span class=\"hljs-function\">    * @param output color\n</span><span class=\"hljs-function\" style=\"color:#B6B18B\">    */</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">template</span><span class=\"hljs-function\"> &lt;</span><span class=\"hljs-function\" style=\"color:#B45EA4\">typename</span><span class=\"hljs-function\"> number&gt;\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">convert</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> intensity&lt;number&gt; &amp;input, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp;output)</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\">    * convert color to intensity\n</span><span class=\"hljs-function\">    *\n</span><span class=\"hljs-function\">    * @tparam number underlying intensity number type\n</span><span class=\"hljs-function\">    *\n</span><span class=\"hljs-function\">    * @param input color\n</span><span class=\"hljs-function\">    * @param output intensity\n</span><span class=\"hljs-function\" style=\"color:#B6B18B\">    */</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">template</span><span class=\"hljs-function\"> &lt;</span><span class=\"hljs-function\" style=\"color:#B45EA4\">typename</span><span class=\"hljs-function\"> number&gt;\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">convert</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp;input, intensity&lt;number&gt; &amp;output)</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\">    * convert a color of this coder space into a space of another coder\n</span><span class=\"hljs-function\">    *\n</span><span class=\"hljs-function\">    * @tparam CODER2 the other coder\n</span><span class=\"hljs-function\">    *\n</span><span class=\"hljs-function\">    * @param input color\n</span><span class=\"hljs-function\">    * @param output color output\n</span><span class=\"hljs-function\" style=\"color:#B6B18B\">    */</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">template</span><span class=\"hljs-function\">&lt;</span><span class=\"hljs-function\" style=\"color:#B45EA4\">typename</span><span class=\"hljs-function\"> CODER2&gt;\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">convert</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp;input, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp;output)</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\">    * convert a pixel from this coder to a pixel of another coder\n</span><span class=\"hljs-function\">    *\n</span><span class=\"hljs-function\">    * @tparam CODER2 the other coder\n</span><span class=\"hljs-function\">    *\n</span><span class=\"hljs-function\">    * @param input input pixel of my coder\n</span><span class=\"hljs-function\">    * @param output the output pixel\n</span><span class=\"hljs-function\">    * @param coder2 the other coder reference\n</span><span class=\"hljs-function\" style=\"color:#B6B18B\">    */</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">template</span><span class=\"hljs-function\">&lt;</span><span class=\"hljs-function\" style=\"color:#B45EA4\">typename</span><span class=\"hljs-function\"> CODER2&gt;\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">convert</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> pixel &amp;input, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">typename</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> CODER2::pixel &amp;output, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> CODER2 &amp;coder2)</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">}\n</span><span class=\"hljs-function\">\n</span></code></pre></pre>","scope":{}},"frontMatter":{},"document":{"name":"docs","groups":[{"title":"Getting Started","items":[{"title":"Setup","route":"getting-started/setup","path":"content/docs/setup.mdx"},{"title":"Features","route":"getting-started/features","path":"content/docs/features.mdx"}]},{"title":"Concepts","items":[{"title":"Numbers","route":"concepts/numbers","path":"content/docs/numbers.mdx"},{"title":"Math","route":"concepts/math","path":"content/docs/math.mdx"},{"title":"RGBA","route":"concepts/rgba","path":"content/docs/rgba.mdx"},{"title":"Pixel Coders","route":"concepts/pixel-coders","path":"content/docs/pixel-coders.mdx"},{"title":"Samplers","route":"concepts/samplers","path":"content/docs/samplers.mdx"},{"title":"Composition","route":"concepts/composition","path":"content/docs/composition.mdx"},{"title":"Bitmaps","route":"concepts/bitmaps","path":"content/docs/bitmaps.mdx"},{"title":"3D Shaders","route":"concepts/3d","path":"content/docs/3d.mdx"},{"title":"Canvas","route":"concepts/canvas","path":"content/docs/canvas.mdx"}]},{"title":"Drawing","items":[{"title":"Rectangles","route":"drawing/rectangles","path":"content/docs/rectangles.mdx"},{"title":"Rounded Shapes","route":"drawing/rounded","path":"content/docs/rounded.mdx"},{"title":"Quadrilaterals","route":"drawing/quadrilaterals","path":"content/docs/quadrilaterals.mdx"},{"title":"Triangle","route":"drawing/triangle","path":"content/docs/triangle.mdx"},{"title":"Triangle Batches","route":"drawing/triangle-batches","path":"content/docs/triangle-batches.mdx"},{"title":"Polygons","route":"drawing/polygons","path":"content/docs/polygons.mdx"},{"title":"Masks","route":"drawing/masks","path":"content/docs/masks.mdx"},{"title":"Path Fills","route":"drawing/path-fills","path":"content/docs/path-fills.mdx"},{"title":"Path Strokes","route":"drawing/path-stroke","path":"content/docs/path-stroke.mdx"},{"title":"Bezier Patches","route":"drawing/bezier-patches","path":"content/docs/patches.mdx"},{"title":"Lines","route":"drawing/lines","path":"content/docs/lines.mdx"},{"title":"Text","route":"drawing/text","path":"content/docs/text.mdx"},{"title":"Gradients","route":"drawing/gradients","path":"content/docs/gradients.mdx"},{"title":"More Samplers","route":"drawing/more-samplers","path":"content/docs/more-samplers.mdx"},{"title":"3D","route":"drawing/3d","path":"content/docs/draw-3d.mdx"}]},{"title":"Geometry","items":[{"title":"Intro","route":"geometry/intro","path":"content/docs/wip.mdx"}]}],"__map":{"getting-started/setup":"content/docs/setup.mdx","getting-started/features":"content/docs/features.mdx","concepts/numbers":"content/docs/numbers.mdx","concepts/math":"content/docs/math.mdx","concepts/rgba":"content/docs/rgba.mdx","concepts/pixel-coders":"content/docs/pixel-coders.mdx","concepts/samplers":"content/docs/samplers.mdx","concepts/composition":"content/docs/composition.mdx","concepts/bitmaps":"content/docs/bitmaps.mdx","concepts/3d":"content/docs/3d.mdx","concepts/canvas":"content/docs/canvas.mdx","drawing/rectangles":"content/docs/rectangles.mdx","drawing/rounded":"content/docs/rounded.mdx","drawing/quadrilaterals":"content/docs/quadrilaterals.mdx","drawing/triangle":"content/docs/triangle.mdx","drawing/triangle-batches":"content/docs/triangle-batches.mdx","drawing/polygons":"content/docs/polygons.mdx","drawing/masks":"content/docs/masks.mdx","drawing/path-fills":"content/docs/path-fills.mdx","drawing/path-stroke":"content/docs/path-stroke.mdx","drawing/bezier-patches":"content/docs/patches.mdx","drawing/lines":"content/docs/lines.mdx","drawing/text":"content/docs/text.mdx","drawing/gradients":"content/docs/gradients.mdx","drawing/more-samplers":"content/docs/more-samplers.mdx","drawing/3d":"content/docs/draw-3d.mdx","geometry/intro":"content/docs/wip.mdx"}}}},"__N_SSG":true}