{"pageProps":{"data":{"slug":"concepts/samplers","content":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Introduction\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Samplers\"), \" are a first class citizen in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"microgl\"), \". think of them as an object,\\nthat can be sampled in the normalized unit square.\"), mdx(\"img\", {\n    src: \"/images/unit_square.png\",\n    style: {\n      marginTop: '2rem'\n    }\n  }), mdx(\"p\", null, \"Samplers can be anything, that can be sampled such as\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"a fixed color\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"a gradient\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"a texture (image)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"effects\")), mdx(\"p\", null, \"Samplers can be though of as 2d shaders\"), mdx(\"h2\", null, \"Sampler interface\"), mdx(\"p\", null, \"samplers are implemented as classes with the following interface. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"struct half_sampler_t {\\n    // rgba info\\n    using rgba = rgba_t<8, 8, 8, 0>;\\n\\n    // the sampler method\\n    inline void sample(const int u, const int v,\\n                        const unsigned bits,\\n                        color_t &output) const {\\n        const unsigned half = (1u<<(bits-1));\\n        output = {255, 0, 0};\\n        if(u > half)\\n          output = {0, 255, 0};\\n    }\\n\\n};\\n\\n\")), mdx(\"p\", null, \"at it's basic form, a sampler should publish it's rgba quantitized info and a sample method,\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"void sample(const int u, const int v, const unsigned bits, color_t &output)\\n\")), mdx(\"p\", null, \"where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"u\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"v\"), \" are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uv\"), \" coordinates handed as fixed point integers with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bits\"), \" precision, this means that:\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1<<bits\"), \" is like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \". you can also transform \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uv\"), \" coordinates to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"float\"), \" point with\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"float uf = float(u)/float(1u<<bits)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"float vf = float(v)/float(1u<<bits)\"))), mdx(\"p\", null, \"if you want to sample from a different number system such as float, double, q, you can use\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"#include <microgl/sampler.h>\\n\\nhalf_sampler_t half_sampler;\\ncolor_t output;\\nfloat u = 0.2f, v = 0.33f;\\n\\nsampling::sample(half_sampler, u, v, microgl::precision::high, output);\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"you can also inherit from \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"<microgl/sampler.h>\"), \" \")), mdx(\"h2\", null, \"Samplers shipped with \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"microgl\")), mdx(\"p\", null, \"microgl is packed with the following samplers\"), mdx(\"h3\", null, \"1. Texture Sampler\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"defined at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<microgl/samplers/texture.h>\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"example at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"/examples/example_sampler_texture.cpp\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"example at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"/examples/example_sampler_texture_wrap.cpp\"))), mdx(\"p\", null, \"This sampler holds a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"bitmap\"\n  }, \"bitmap\"), \" and samples from it\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"template <typename Bitmap,\\n          texture_filter filter=texture_filter::NearestNeighboor,\\n          bool tint=false,\\n          texture_wrap wrap_u=texture_wrap::None,\\n          texture_wrap wrap_v=texture_wrap::None>\\nstruct texture {\\n  ...\\n\\n    // constructors\\n    texture()\\n    texture(Bitmap * bitmap)\\n    texture(Bitmap * bitmap, const color_t &tint_color)\\n\\n    // public interface\\n    void updateBitmap(Bitmap * bitmap)\\n    Bitmap & bitmap()\\n    void updateBorderColor(const color_t & color)\\n    void updateTintColor(const color_t & color)\\n    inline void sample(const rint u, const rint v,\\n                            const uint8_t bits,\\n                            color_t &output) const    \\n  ...\\n}\\n\")), mdx(\"p\", null, \"where:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"Bitmap\")), \" is the bitmap type to sampler from \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"filter\")), \" is one of\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"texture_filter::NearestNeighboor\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"texture_filter::Bilinear\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"tint\")), \" is a flag to enable color tinting, off by default\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"wrap_u\")), \" indicates how to handle horizontal sampling overflows, one of\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"texture_wrap::None\")), \" - most economic\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"texture_wrap::Clamp\")), \" - clamp overflow to 1\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"texture_wrap::ClampToBorderColor\")), \" - overflows will sample from border color\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"texture_wrap::Repeat\")), \" - overflows will repeat in cyclic order\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"wrap_v\")), \" same as \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"wrap_u\")), \" but for vertical sampling overflows\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"a texture will automatically use the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"rgba\"), \" info of the bitmap it samples from \")), mdx(\"img\", {\n    src: \"/images/sampler_texture.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h3\", null, \"2. Flat Color Sampler\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"defined at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<microgl/samplers/flat_color.h>\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"example at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"/examples/example_sampler_flat_color.cpp\"))), mdx(\"p\", null, \"this is a very trivial sampler that samples a single color, it's declaration is\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"template<typename rgba_=rgba_t<8,8,8,0>>\\nstruct flat_color {\\n    // rgba info\\n    using rgba = rgba_;\\n\\n    // constructors\\n    explicit flat_color()\\n    explicit flat_color(const color_t & $color)\\n\\n    // color\\n    color_t color;\\n}\\n\")), mdx(\"img\", {\n    src: \"/images/sampler_flat.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h3\", null, \"2. Line Gradient Sampler\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"defined at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<microgl/samplers/line_linear_gradient.h>\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"example at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"/examples/example_sampler_gradient_line.cpp\"))), mdx(\"p\", null, \"the line gradient defines color stops on a line on which it samples. The line definition\\nis relative to unit rectangle. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"template <typename number, // the number type\\n          unsigned N=10, // the number of stops\\n          typename rgba_=rgba_t<8,8,8,0>, // the rgba info\\n          enum precision $precision=precision::medium, // the precision\\n          bool useBigIntegers=false> // big integers are required for high precision\\nstruct line_linear_gradient {\\n    using rgba = rgba_;\\n\\n    // constructor\\n    line_linear_gradient()\\n    line_linear_gradient(const vec2<number> & start, const vec2<number> & end)\\n\\n    // set a new line relative to the unit rectangle\\n    void setNewLine(const vec2<number> & start, const vec2<number> & end)\\n    // add a new color stop on a fraction of the line\\n    void addStop(const number & where, const color_t &color)\\n}    \\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number\"), \" template argument can be any type that implements a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"numbers\"\n  }, \"number system\"))), mdx(\"img\", {\n    src: \"/images/sampler_line_linear_gradient.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h3\", null, \"3. Angular Linear Gradient Sampler\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"defined at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<microgl/samplers/angular_linear_gradient.h>\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"example at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"/examples/example_sampler_gradient_angular_linear.cpp\"))), mdx(\"p\", null, \"This gradient is inferred by a given angle to create a line at the unit rectangle. the user can then\\ndefine the color stops.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"template <typename number, // the number type\\n          unsigned N=10, // the number of stops\\n          typename rgba_=rgba_t<8,8,8,0>, // the rgba info\\n          enum precision $precision=precision::medium, // the precision\\n          bool useBigIntegers=false> // big integers are required for high precision\\nstruct angular_linear_gradient : public line_linear_gradient<....> {\\n    using rgba = rgba_;\\n\\n    // constructor\\n    angular_linear_gradient()\\n    angular_linear_gradient(const number & angle_degrees)\\n\\n    // set a new angle\\n    void setAngle(number angle_degrees)\\n    // add a new color stop on a fraction of the line defined by the angle\\n    void addStop(const number & where, const color_t &color)\\n}    \\n\")), mdx(\"img\", {\n    src: \"/images/sampler_angular_linear_gradient.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h3\", null, \"4. Axial Linear Gradient Sampler\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"defined at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<microgl/samplers/axial_linear_gradient.h>\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"example at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"/examples/example_sampler_gradient_axial.cpp\"))), mdx(\"p\", null, \"This gradient is a faster variant if you need any number of stops but with angle,\\nthat is a modulu of 45 (0, 45, 90, 135, 180, 225, 270, 315, 360)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"template <unsigned degree=0, // the degree\\n          unsigned N=10, // the number of stops\\n          typename rgba_=rgba_t<8,8,8,0>, // the rgba info\\n          enum precision $precision=precision::medium, // the precision\\n          bool useBigIntegers=false> // big integers are required for high precision\\nstruct axial_linear_gradient {\\n    using rgba = rgba_;\\n\\n    template <typename number>\\n    void addStop(const number & where, const color_t &color)\\n}    \\n\")), mdx(\"img\", {\n    src: \"/images/sampler_grad_axial.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h3\", null, \"5. 2 Colors Gradient Sampler\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"defined at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<microgl/samplers/linear_gradient_2_colors.h>\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"example at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"/examples/example_sampler_gradient_2_colors_fast.cpp\"))), mdx(\"p\", null, \"This gradient is a very fast variant if you need only 2 colors stops but with angle,\\nthat is a modulu of 45 (0, 45, 90, 135, 180, 225, 270, 315, 360)\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"template <unsigned degree=0, // the degree\\n          typename rgba_=rgba_t<8,8,8,0>, // the rgba info\\n          bool useBigIntegers=false> // big integers are required for high precision\\nstruct linear_gradient_2_colors {\\n    using rgba = rgba_;\\n\\n    // constructor\\n    linear_gradient_2_colors(const color_t& color_1, const color_t& color_2)\\n\\n    color_t color1, color2;\\n}    \\n\")), mdx(\"img\", {\n    src: \"/images/sampler_grad_2_colors_fast.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h3\", null, \"6. Fast Radial Gradient Sampler\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"defined at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<microgl/samplers/fast_radial_gradient.h>\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"example at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"/examples/example_sampler_gradient_radial.cpp\"))), mdx(\"p\", null, \"This gradient is a fast radial gradient.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"template <typename number, \\n          unsigned N=10, \\n          typename rgba_=rgba_t<8,8,8,0>,\\n          enum precision $precision=precision::medium, \\n          bool useBigIntegers=false>\\nstruct fast_radial_gradient {\\n    using rgba = rgba_;\\n\\n    fast_radial_gradient();\\n    fast_radial_gradient(const number &cx, const number &cy, const number &radius)\\n\\n    // set new radial with center x and y and radius\\n    void setNewRadial(const number &cx, const number &cy, const number &radius)\\n    void addStop(const number & where, const color_t &color)\\n}\\n\")), mdx(\"img\", {\n    src: \"/images/sampler_grad_radial.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h3\", null, \"7. Mask Sampler\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"defined at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<microgl/samplers/mask_sampler.h>\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"example at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"/examples/example_sampler_masking_sampler.cpp\"))), mdx(\"p\", null, \"This sampler can mask a sampler with a different sampler, this is very useful if you want to\\ndraw a masked image on the canvas.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"/**\\n* a sampler that masks a sampler with another sampler\\n*\\n* @tparam chrome the chrome channel config for mask sampler\\n* @tparam sampler_from a sampler you want to mask\\n* @tparam sampler_mask a sampler that acts as a mask\\n* @tparam alpha_fallback this sampler inherits the alpha bits of sampler_from,\\n*                        and in case it doesn't have an alpha channel (rgba::a=0),\\n*                        we can make an alpha channel with `alpha_fallback` bits\\n*/\\ntemplate<masks::chrome_mode chrome, // the chrome mode of the mask (the channel to use for mask)\\n        class sampler_from, // the sampler you want to mask\\n        class sampler_mask, // the mask sampler\\n        uint8_t alpha_fallback=8> // \\nstruct mask_sampler {\\n\\n    // constructor\\n    mask_sampler(const sampler_from & from, const sampler_mask & mask)\\n}\\n\")), mdx(\"p\", null, \"the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"chrome\"), \" template argument is enum with the following values:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#\"\n  }, \"chrome_mode::red_channel\"), \" - use the red channel as a mask of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"sampler_mask\"), \" \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#\"\n  }, \"chrome_mode::green_channel\"), \" - use the green channel as a mask of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"sampler_mask\"), \" \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#\"\n  }, \"chrome_mode::blue_channel\"), \" - use the blue channel as a mask of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"sampler_mask\"), \" \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#\"\n  }, \"chrome_mode::alpha_channel\"), \" - use the alpha channel as a mask of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"sampler_mask\"), \" \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#\"\n  }, \"chrome_mode::red_channel_inverted\"), \" - use the inverted red channel\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#\"\n  }, \"chrome_mode::green_channel_inverted\"), \" - use the inverted green channel\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#\"\n  }, \"chrome_mode::blue_channel_inverted\"), \" - use the inverted blue channel\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#\"\n  }, \"chrome_mode::alpha_channel_inverted\"), \" - use the inverted alpha channel\")), mdx(\"img\", {\n    src: \"/images/sampler_masking.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h3\", null, \"8. Checker Board Sampler\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"defined at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<microgl/samplers/checker_board.h>\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"example at \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"/examples/example_sampler_checkerboard.cpp\"))), mdx(\"p\", null, \"This sampler can draw a checker board pattern with\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Configurable two colors\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Configurable horizontal and vertical splits\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"/**\\n  * checker board pattern sampler\\n  *\\n  * @tparam rgba_ the rgba info\\n  */\\ntemplate<typename rgba_=rgba_t<8,8,8,0>>\\nstruct checker_board {\\n    using rgba = rgba_;\\n    \\n    /**\\n      * constructor\\n      *\\n      * @param color1 1st color\\n      * @param color2 2nd color\\n      * @param horizontal horizontal splits count\\n      * @param vertical vertical split count\\n      */\\n    explicit checker_board(const color_t & color1,\\n                            const color_t & color2,\\n                            unsigned horizontal=2,\\n                            unsigned vertical=2)\\n    }\\n\")), mdx(\"img\", {\n    src: \"/images/sampler_checker_board.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"microgl::sampling\"), \" namespace\"), mdx(\"p\", null, \"This namespace also defines the following utility methods\"), mdx(\"h3\", null, \"sample from another number system\"), mdx(\"p\", null, \"sample uv coords from sampler with a different number system.\\nThis is handy because samplers work in quantized space to be more\\nefficient and sometimes it is not convenient. This method will convert\\nthe uv coords into fixed points and then sample from the sampler.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"/**\\n* @tparam Sampler the sampler type\\n* @tparam number the number type\\n* \\n* @param sampler the sampler reference \\n* @param u the u coord\\n* @param v the v coord\\n* @param p precision can be {low, medium, high, amazing}\\n* @param output output color\\n*/\\ntemplate<class Sampler, typename number>\\ninline void sample(const Sampler & sampler,\\n                   const number &u, const number &v,\\n                   const enum microgl::precision &p,\\n                   color_t &output) {\\n\")), mdx(\"h3\", null, mdx(\"inlineCode\", {\n    parentName: \"h3\"\n  }, \"base_sampler\"), \" class\"), mdx(\"p\", null, \"You can extend this class to include other utility methods inside your class.\\nThis is a nice container, that can wrap samplers and also invoke their sampling\\nbehaviour via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"crpt\"), \" compile-time polymorphism. I prefer not to use it because it\\nmakes the definition a bit combersome and long with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"c++\"), \" templates quirks \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"/**\\n* @tparam rgba_ the rgba_t info type\\n* @tparam impl the type of the derived class\\n*/\\ntemplate<typename rgba_, typename impl>\\nclass base_sampler\\n\")));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<h1 class=\"css-0\">Introduction</h1><p class=\"css-0\"><style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">Samplers</strong> are a first class citizen in <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">microgl</div>. think of them as an object,\nthat can be sampled in the normalized unit square.</p><img src=\"/images/unit_square.png\" style=\"margin-top:2rem\"/><p class=\"css-0\">Samplers can be anything, that can be sampled such as</p><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">a fixed color</li><li class=\"css-b0qdn7\">a gradient</li><li class=\"css-b0qdn7\">a texture (image)</li><li class=\"css-b0qdn7\">effects</li></ul><p class=\"css-0\">Samplers can be though of as 2d shaders</p><h2 class=\"css-0\">Sampler interface</h2><p class=\"css-0\">samplers are implemented as classes with the following interface. </p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span class=\"hljs-class\" style=\"color:#B45EA4\">struct</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">half_sampler_t</span><span class=\"hljs-class\"> {</span><span>\n</span><span>    </span><span style=\"color:#B6B18B\">// rgba info</span><span>\n</span><span>    </span><span style=\"color:#B45EA4\">using</span><span> rgba = </span><span style=\"color:#B45EA4\">rgba_t</span><span>&lt;</span><span style=\"color:#E7CE56\">8</span><span>, </span><span style=\"color:#E7CE56\">8</span><span>, </span><span style=\"color:#E7CE56\">8</span><span>, </span><span style=\"color:#E7CE56\">0</span><span>&gt;;\n</span>\n<span>    </span><span style=\"color:#B6B18B\">// the sampler method</span><span>\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">inline</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">sample</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> u, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> v,\n</span><span class=\"hljs-function\" style=\"color:#E7CE56\">                        </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">unsigned</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> bits,\n</span><span class=\"hljs-function\" style=\"color:#E7CE56\">                        </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp;output)</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\"> </span><span>{\n</span><span>        </span><span style=\"color:#B45EA4\">const</span><span> </span><span style=\"color:#B45EA4\">unsigned</span><span> half = (</span><span style=\"color:#E7CE56\">1u</span><span>&lt;&lt;(bits</span><span style=\"color:#E7CE56\">-1</span><span>));\n</span><span>        output = {</span><span style=\"color:#E7CE56\">255</span><span>, </span><span style=\"color:#E7CE56\">0</span><span>, </span><span style=\"color:#E7CE56\">0</span><span>};\n</span><span>        </span><span style=\"color:#B45EA4\">if</span><span>(u &gt; half)\n</span><span>          output = {</span><span style=\"color:#E7CE56\">0</span><span>, </span><span style=\"color:#E7CE56\">255</span><span>, </span><span style=\"color:#E7CE56\">0</span><span>};\n</span>    }\n<!-- -->\n<!-- -->};\n<!-- -->\n<!-- -->\n</code></pre></pre><p class=\"css-0\">at it&#x27;s basic form, a sampler should publish it&#x27;s rgba quantitized info and a sample method,</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">sample</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> u, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> v, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">unsigned</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> bits, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp;output)</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span></code></pre></pre><p class=\"css-0\">where <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">u</div> and <div class=\"css-qskmz3\">v</div> are <div class=\"css-qskmz3\">uv</div> coordinates handed as fixed point integers with <div class=\"css-qskmz3\">bits</div> precision, this means that:\n<div class=\"css-qskmz3\">1&lt;&lt;bits</div> is like <div class=\"css-qskmz3\">1</div>. you can also transform <div class=\"css-qskmz3\">uv</div> coordinates to <div class=\"css-qskmz3\">float</div> point with</p><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">float uf = float(u)/float(1u&lt;&lt;bits)</div></li><li class=\"css-b0qdn7\"><div class=\"css-qskmz3\">float vf = float(v)/float(1u&lt;&lt;bits)</div></li></ul><p class=\"css-0\">if you want to sample from a different number system such as float, double, q, you can use</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#E7CE56\">#</span><span class=\"hljs-meta-keyword\" style=\"color:#E7CE56\">include</span><span style=\"color:#E7CE56\"> </span><span class=\"hljs-meta-string\" style=\"color:#E7CE56\">&lt;microgl/sampler.h&gt;</span><span>\n</span>\n<span></span><span style=\"color:#B45EA4\">half_sampler_t</span><span> half_sampler;\n</span><span></span><span style=\"color:#B45EA4\">color_t</span><span> output;\n</span><span></span><span style=\"color:#B45EA4\">float</span><span> u = </span><span style=\"color:#E7CE56\">0.2f</span><span>, v = </span><span style=\"color:#E7CE56\">0.33f</span><span>;\n</span>\n<!-- -->sampling::sample(half_sampler, u, v, microgl::precision::high, output);\n<!-- -->\n</code></pre></pre><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">you can also inherit from <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">&lt;microgl/sampler.h&gt;</strong> </p></blockquote><h2 class=\"css-0\">Samplers shipped with <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">microgl</div></h2><p class=\"css-0\">microgl is packed with the following samplers</p><h3 class=\"css-0\">1. Texture Sampler</h3><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">defined at <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">&lt;microgl/samplers/texture.h&gt;</div></li><li class=\"css-b0qdn7\">example at <div class=\"css-qskmz3\">/examples/example_sampler_texture.cpp</div></li><li class=\"css-b0qdn7\">example at <div class=\"css-qskmz3\">/examples/example_sampler_texture_wrap.cpp</div></li></ul><p class=\"css-0\">This sampler holds a <style data-emotion=\"css 1kc89wa\">.css-1kc89wa{color:purple.500;}</style><a class=\"chakra-link css-1kc89wa\" href=\"bitmap\">bitmap</a> and samples from it</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B45EA4\">template</span><span> &lt;</span><span style=\"color:#B45EA4\">typename</span><span> Bitmap,\n</span>          texture_filter filter=texture_filter::NearestNeighboor,\n<span>          </span><span style=\"color:#B45EA4\">bool</span><span> tint=</span><span style=\"color:#E7CE56\">false</span><span>,\n</span>          texture_wrap wrap_u=texture_wrap::None,\n<!-- -->          texture_wrap wrap_v=texture_wrap::None&gt;\n<!-- -->struct texture {\n<!-- -->  ...\n<!-- -->\n<span>    </span><span style=\"color:#B6B18B\">// constructors</span><span>\n</span>    texture()\n<!-- -->    texture(Bitmap * bitmap)\n<span>    texture(Bitmap * bitmap, </span><span style=\"color:#B45EA4\">const</span><span> </span><span style=\"color:#B45EA4\">color_t</span><span> &amp;tint_color)\n</span>\n<span>    </span><span style=\"color:#B6B18B\">// public interface</span><span>\n</span><span>    </span><span style=\"color:#B45EA4\">void</span><span> updateBitmap(Bitmap * bitmap)\n</span>    Bitmap &amp; bitmap()\n<span>    </span><span style=\"color:#B45EA4\">void</span><span> updateBorderColor(</span><span style=\"color:#B45EA4\">const</span><span> </span><span style=\"color:#B45EA4\">color_t</span><span> &amp; color)\n</span><span>    </span><span style=\"color:#B45EA4\">void</span><span> updateTintColor(</span><span style=\"color:#B45EA4\">const</span><span> </span><span style=\"color:#B45EA4\">color_t</span><span> &amp; color)\n</span><span>    </span><span style=\"color:#B45EA4\">inline</span><span> </span><span style=\"color:#B45EA4\">void</span><span> sample(</span><span style=\"color:#B45EA4\">const</span><span> rint u, </span><span style=\"color:#B45EA4\">const</span><span> rint v,\n</span><span>                            </span><span style=\"color:#B45EA4\">const</span><span> </span><span style=\"color:#B45EA4\">uint8_t</span><span> bits,\n</span><span>                            </span><span style=\"color:#B45EA4\">color_t</span><span> &amp;output) </span><span style=\"color:#B45EA4\">const</span><span>    \n</span>  ...\n<!-- -->}\n<!-- -->\n</code></pre></pre><p class=\"css-0\">where:</p><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\"><style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">Bitmap</div></strong> is the bitmap type to sampler from </li><li class=\"css-b0qdn7\"><strong class=\"css-10ircq3\"><div class=\"css-qskmz3\">filter</div></strong> is one of<ul class=\"css-0\"><li class=\"css-b0qdn7\"><strong class=\"css-10ircq3\"><div class=\"css-qskmz3\">texture_filter::NearestNeighboor</div></strong></li><li class=\"css-b0qdn7\"><strong class=\"css-10ircq3\"><div class=\"css-qskmz3\">texture_filter::Bilinear</div></strong></li></ul></li><li class=\"css-b0qdn7\"><strong class=\"css-10ircq3\"><div class=\"css-qskmz3\">tint</div></strong> is a flag to enable color tinting, off by default</li><li class=\"css-b0qdn7\"><strong class=\"css-10ircq3\"><div class=\"css-qskmz3\">wrap_u</div></strong> indicates how to handle horizontal sampling overflows, one of<ul class=\"css-0\"><li class=\"css-b0qdn7\"><strong class=\"css-10ircq3\"><div class=\"css-qskmz3\">texture_wrap::None</div></strong> - most economic</li><li class=\"css-b0qdn7\"><strong class=\"css-10ircq3\"><div class=\"css-qskmz3\">texture_wrap::Clamp</div></strong> - clamp overflow to 1</li><li class=\"css-b0qdn7\"><strong class=\"css-10ircq3\"><div class=\"css-qskmz3\">texture_wrap::ClampToBorderColor</div></strong> - overflows will sample from border color</li><li class=\"css-b0qdn7\"><strong class=\"css-10ircq3\"><div class=\"css-qskmz3\">texture_wrap::Repeat</div></strong> - overflows will repeat in cyclic order</li></ul></li><li class=\"css-b0qdn7\"><strong class=\"css-10ircq3\"><div class=\"css-qskmz3\">wrap_v</div></strong> same as <strong class=\"css-10ircq3\"><div class=\"css-qskmz3\">wrap_u</div></strong> but for vertical sampling overflows</li></ul><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">a texture will automatically use the <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">rgba</strong> info of the bitmap it samples from </p></blockquote><img src=\"/images/sampler_texture.png\" style=\"height:250px;margin:auto\"/><h3 class=\"css-0\">2. Flat Color Sampler</h3><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">defined at <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">&lt;microgl/samplers/flat_color.h&gt;</div></li><li class=\"css-b0qdn7\">example at <div class=\"css-qskmz3\">/examples/example_sampler_flat_color.cpp</div></li></ul><p class=\"css-0\">this is a very trivial sampler that samples a single color, it&#x27;s declaration is</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B45EA4\">template</span><span>&lt;</span><span style=\"color:#B45EA4\">typename</span><span> rgba_=</span><span style=\"color:#B45EA4\">rgba_t</span><span>&lt;</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">0</span><span>&gt;&gt;\n</span>struct flat_color {\n<span>    </span><span style=\"color:#B6B18B\">// rgba info</span><span>\n</span><span>    </span><span style=\"color:#B45EA4\">using</span><span> rgba = rgba_;\n</span>\n<span>    </span><span style=\"color:#B6B18B\">// constructors</span><span>\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">explicit</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">flat_color</span><span class=\"hljs-function\" style=\"color:#E7CE56\">()</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">explicit</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">flat_color</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp; $color)</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B6B18B\">// color</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\"> color</span><span>;\n</span>}\n<!-- -->\n</code></pre></pre><img src=\"/images/sampler_flat.png\" style=\"height:250px;margin:auto\"/><h3 class=\"css-0\">2. Line Gradient Sampler</h3><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">defined at <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">&lt;microgl/samplers/line_linear_gradient.h&gt;</div></li><li class=\"css-b0qdn7\">example at <div class=\"css-qskmz3\">/examples/example_sampler_gradient_line.cpp</div></li></ul><p class=\"css-0\">the line gradient defines color stops on a line on which it samples. The line definition\nis relative to unit rectangle. </p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B45EA4\">template</span><span> &lt;</span><span style=\"color:#B45EA4\">typename</span><span> number, </span><span style=\"color:#B6B18B\">// the number type</span><span>\n</span><span>          </span><span style=\"color:#B45EA4\">unsigned</span><span> N=</span><span style=\"color:#E7CE56\">10</span><span>, </span><span style=\"color:#B6B18B\">// the number of stops</span><span>\n</span><span>          </span><span style=\"color:#B45EA4\">typename</span><span> rgba_=</span><span style=\"color:#B45EA4\">rgba_t</span><span>&lt;</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">0</span><span>&gt;, </span><span style=\"color:#B6B18B\">// the rgba info</span><span>\n</span><span>          </span><span style=\"color:#B45EA4\">enum</span><span> precision $precision=precision::medium, </span><span style=\"color:#B6B18B\">// the precision</span><span>\n</span><span>          </span><span style=\"color:#B45EA4\">bool</span><span> useBigIntegers=</span><span style=\"color:#E7CE56\">false</span><span>&gt; </span><span style=\"color:#B6B18B\">// big integers are required for high precision</span><span>\n</span>struct line_linear_gradient {\n<span>    </span><span style=\"color:#B45EA4\">using</span><span> rgba = rgba_;\n</span>\n<span>    </span><span style=\"color:#B6B18B\">// constructor</span><span>\n</span>    line_linear_gradient()\n<span>    line_linear_gradient(</span><span style=\"color:#B45EA4\">const</span><span> vec2&lt;number&gt; &amp; start, </span><span style=\"color:#B45EA4\">const</span><span> vec2&lt;number&gt; &amp; end)\n</span>\n<span>    </span><span style=\"color:#B6B18B\">// set a new line relative to the unit rectangle</span><span>\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">setNewLine</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> vec2&lt;number&gt; &amp; start, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> vec2&lt;number&gt; &amp; end)</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B6B18B\">// add a new color stop on a fraction of the line</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">addStop</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> number &amp; where, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp;color)</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">}    \n</span><span class=\"hljs-function\">\n</span></code></pre></pre><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">the <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">number</div> template argument can be any type that implements a <style data-emotion=\"css 1kc89wa\">.css-1kc89wa{color:purple.500;}</style><a class=\"chakra-link css-1kc89wa\" href=\"numbers\">number system</a></p></blockquote><img src=\"/images/sampler_line_linear_gradient.png\" style=\"height:250px;margin:auto\"/><h3 class=\"css-0\">3. Angular Linear Gradient Sampler</h3><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">defined at <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">&lt;microgl/samplers/angular_linear_gradient.h&gt;</div></li><li class=\"css-b0qdn7\">example at <div class=\"css-qskmz3\">/examples/example_sampler_gradient_angular_linear.cpp</div></li></ul><p class=\"css-0\">This gradient is inferred by a given angle to create a line at the unit rectangle. the user can then\ndefine the color stops.</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B45EA4\">template</span><span> &lt;</span><span style=\"color:#B45EA4\">typename</span><span> number, </span><span style=\"color:#B6B18B\">// the number type</span><span>\n</span><span>          </span><span style=\"color:#B45EA4\">unsigned</span><span> N=</span><span style=\"color:#E7CE56\">10</span><span>, </span><span style=\"color:#B6B18B\">// the number of stops</span><span>\n</span><span>          </span><span style=\"color:#B45EA4\">typename</span><span> rgba_=</span><span style=\"color:#B45EA4\">rgba_t</span><span>&lt;</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">0</span><span>&gt;, </span><span style=\"color:#B6B18B\">// the rgba info</span><span>\n</span><span>          </span><span style=\"color:#B45EA4\">enum</span><span> precision $precision=precision::medium, </span><span style=\"color:#B6B18B\">// the precision</span><span>\n</span><span>          </span><span style=\"color:#B45EA4\">bool</span><span> useBigIntegers=</span><span style=\"color:#E7CE56\">false</span><span>&gt; </span><span style=\"color:#B6B18B\">// big integers are required for high precision</span><span>\n</span><span>struct angular_linear_gradient : </span><span style=\"color:#B45EA4\">public</span><span> line_linear_gradient&lt;....&gt; {\n</span><span>    </span><span style=\"color:#B45EA4\">using</span><span> rgba = rgba_;\n</span>\n<span>    </span><span style=\"color:#B6B18B\">// constructor</span><span>\n</span>    angular_linear_gradient()\n<span>    angular_linear_gradient(</span><span style=\"color:#B45EA4\">const</span><span> number &amp; angle_degrees)\n</span>\n<span>    </span><span style=\"color:#B6B18B\">// set a new angle</span><span>\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">setAngle</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(number angle_degrees)</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B6B18B\">// add a new color stop on a fraction of the line defined by the angle</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">addStop</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> number &amp; where, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp;color)</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">}    \n</span><span class=\"hljs-function\">\n</span></code></pre></pre><img src=\"/images/sampler_angular_linear_gradient.png\" style=\"height:250px;margin:auto\"/><h3 class=\"css-0\">4. Axial Linear Gradient Sampler</h3><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">defined at <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">&lt;microgl/samplers/axial_linear_gradient.h&gt;</div></li><li class=\"css-b0qdn7\">example at <div class=\"css-qskmz3\">/examples/example_sampler_gradient_axial.cpp</div></li></ul><p class=\"css-0\">This gradient is a faster variant if you need any number of stops but with angle,\nthat is a modulu of 45 (0, 45, 90, 135, 180, 225, 270, 315, 360)</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B45EA4\">template</span><span> &lt;</span><span style=\"color:#B45EA4\">unsigned</span><span> degree=</span><span style=\"color:#E7CE56\">0</span><span>, </span><span style=\"color:#B6B18B\">// the degree</span><span>\n</span><span>          </span><span style=\"color:#B45EA4\">unsigned</span><span> N=</span><span style=\"color:#E7CE56\">10</span><span>, </span><span style=\"color:#B6B18B\">// the number of stops</span><span>\n</span><span>          </span><span style=\"color:#B45EA4\">typename</span><span> rgba_=</span><span style=\"color:#B45EA4\">rgba_t</span><span>&lt;</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">0</span><span>&gt;, </span><span style=\"color:#B6B18B\">// the rgba info</span><span>\n</span><span>          </span><span style=\"color:#B45EA4\">enum</span><span> precision $precision=precision::medium, </span><span style=\"color:#B6B18B\">// the precision</span><span>\n</span><span>          </span><span style=\"color:#B45EA4\">bool</span><span> useBigIntegers=</span><span style=\"color:#E7CE56\">false</span><span>&gt; </span><span style=\"color:#B6B18B\">// big integers are required for high precision</span><span>\n</span>struct axial_linear_gradient {\n<span>    </span><span style=\"color:#B45EA4\">using</span><span> rgba = rgba_;\n</span>\n<span>    </span><span style=\"color:#B45EA4\">template</span><span> &lt;</span><span style=\"color:#B45EA4\">typename</span><span> number&gt;\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">addStop</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> number &amp; where, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp;color)</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">}    \n</span><span class=\"hljs-function\">\n</span></code></pre></pre><img src=\"/images/sampler_grad_axial.png\" style=\"height:250px;margin:auto\"/><h3 class=\"css-0\">5. 2 Colors Gradient Sampler</h3><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">defined at <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">&lt;microgl/samplers/linear_gradient_2_colors.h&gt;</div></li><li class=\"css-b0qdn7\">example at <div class=\"css-qskmz3\">/examples/example_sampler_gradient_2_colors_fast.cpp</div></li></ul><p class=\"css-0\">This gradient is a very fast variant if you need only 2 colors stops but with angle,\nthat is a modulu of 45 (0, 45, 90, 135, 180, 225, 270, 315, 360)</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B45EA4\">template</span><span> &lt;</span><span style=\"color:#B45EA4\">unsigned</span><span> degree=</span><span style=\"color:#E7CE56\">0</span><span>, </span><span style=\"color:#B6B18B\">// the degree</span><span>\n</span><span>          </span><span style=\"color:#B45EA4\">typename</span><span> rgba_=</span><span style=\"color:#B45EA4\">rgba_t</span><span>&lt;</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">0</span><span>&gt;, </span><span style=\"color:#B6B18B\">// the rgba info</span><span>\n</span><span>          </span><span style=\"color:#B45EA4\">bool</span><span> useBigIntegers=</span><span style=\"color:#E7CE56\">false</span><span>&gt; </span><span style=\"color:#B6B18B\">// big integers are required for high precision</span><span>\n</span>struct linear_gradient_2_colors {\n<span>    </span><span style=\"color:#B45EA4\">using</span><span> rgba = rgba_;\n</span>\n<span>    </span><span style=\"color:#B6B18B\">// constructor</span><span>\n</span><span>    linear_gradient_2_colors(</span><span style=\"color:#B45EA4\">const</span><span> </span><span style=\"color:#B45EA4\">color_t</span><span>&amp; color_1, </span><span style=\"color:#B45EA4\">const</span><span> </span><span style=\"color:#B45EA4\">color_t</span><span>&amp; color_2)\n</span>\n<span>    </span><span style=\"color:#B45EA4\">color_t</span><span> color1, color2;\n</span>}    \n<!-- -->\n</code></pre></pre><img src=\"/images/sampler_grad_2_colors_fast.png\" style=\"height:250px;margin:auto\"/><h3 class=\"css-0\">6. Fast Radial Gradient Sampler</h3><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">defined at <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">&lt;microgl/samplers/fast_radial_gradient.h&gt;</div></li><li class=\"css-b0qdn7\">example at <div class=\"css-qskmz3\">/examples/example_sampler_gradient_radial.cpp</div></li></ul><p class=\"css-0\">This gradient is a fast radial gradient.</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B45EA4\">template</span><span> &lt;</span><span style=\"color:#B45EA4\">typename</span><span> number, \n</span><span>          </span><span style=\"color:#B45EA4\">unsigned</span><span> N=</span><span style=\"color:#E7CE56\">10</span><span>, \n</span><span>          </span><span style=\"color:#B45EA4\">typename</span><span> rgba_=</span><span style=\"color:#B45EA4\">rgba_t</span><span>&lt;</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">0</span><span>&gt;,\n</span><span>          </span><span style=\"color:#B45EA4\">enum</span><span> precision $precision=precision::medium, \n</span><span>          </span><span style=\"color:#B45EA4\">bool</span><span> useBigIntegers=</span><span style=\"color:#E7CE56\">false</span><span>&gt;\n</span>struct fast_radial_gradient {\n<span>    </span><span style=\"color:#B45EA4\">using</span><span> rgba = rgba_;\n</span>\n<!-- -->    fast_radial_gradient();\n<span>    fast_radial_gradient(</span><span style=\"color:#B45EA4\">const</span><span> number &amp;cx, </span><span style=\"color:#B45EA4\">const</span><span> number &amp;cy, </span><span style=\"color:#B45EA4\">const</span><span> number &amp;radius)\n</span>\n<span>    </span><span style=\"color:#B6B18B\">// set new radial with center x and y and radius</span><span>\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">setNewRadial</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> number &amp;cx, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> number &amp;cy, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> number &amp;radius)</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">addStop</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> number &amp; where, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp;color)</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">}\n</span><span class=\"hljs-function\">\n</span></code></pre></pre><img src=\"/images/sampler_grad_radial.png\" style=\"height:250px;margin:auto\"/><h3 class=\"css-0\">7. Mask Sampler</h3><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">defined at <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">&lt;microgl/samplers/mask_sampler.h&gt;</div></li><li class=\"css-b0qdn7\">example at <div class=\"css-qskmz3\">/examples/example_sampler_masking_sampler.cpp</div></li></ul><p class=\"css-0\">This sampler can mask a sampler with a different sampler, this is very useful if you want to\ndraw a masked image on the canvas.</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B6B18B\">/**\n</span><span style=\"color:#B6B18B\">* a sampler that masks a sampler with another sampler\n</span><span style=\"color:#B6B18B\">*\n</span><span style=\"color:#B6B18B\">* @tparam chrome the chrome channel config for mask sampler\n</span><span style=\"color:#B6B18B\">* @tparam sampler_from a sampler you want to mask\n</span><span style=\"color:#B6B18B\">* @tparam sampler_mask a sampler that acts as a mask\n</span><span style=\"color:#B6B18B\">* @tparam alpha_fallback this sampler inherits the alpha bits of sampler_from,\n</span><span style=\"color:#B6B18B\">*                        and in case it doesn&#x27;t have an alpha channel (rgba::a=0),\n</span><span style=\"color:#B6B18B\">*                        we can make an alpha channel with `alpha_fallback` bits\n</span><span style=\"color:#B6B18B\">*/</span><span>\n</span><span></span><span style=\"color:#B45EA4\">template</span><span>&lt;masks::chrome_mode chrome, </span><span style=\"color:#B6B18B\">// the chrome mode of the mask (the channel to use for mask)</span><span>\n</span><span>        </span><span class=\"hljs-class\" style=\"color:#B45EA4\">class</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">sampler_from</span><span class=\"hljs-class\">, // </span><span class=\"hljs-class\" style=\"color:#78BB65\">the</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">sampler</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">you</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">want</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">to</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">mask</span><span class=\"hljs-class\">\n</span><span class=\"hljs-class\">        </span><span class=\"hljs-class\" style=\"color:#B45EA4\">class</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">sampler_mask</span><span class=\"hljs-class\">, // </span><span class=\"hljs-class\" style=\"color:#78BB65\">the</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">mask</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">sampler</span><span class=\"hljs-class\">\n</span><span class=\"hljs-class\">        </span><span class=\"hljs-class\" style=\"color:#78BB65\">uint8_t</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">alpha_fallback</span><span class=\"hljs-class\">=</span><span style=\"color:#E7CE56\">8</span><span>&gt; </span><span style=\"color:#B6B18B\">// </span><span>\n</span><span></span><span class=\"hljs-class\" style=\"color:#B45EA4\">struct</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">mask_sampler</span><span class=\"hljs-class\"> {</span><span>\n</span>\n<span>    </span><span style=\"color:#B6B18B\">// constructor</span><span>\n</span><span>    mask_sampler(</span><span style=\"color:#B45EA4\">const</span><span> sampler_from &amp; from, </span><span style=\"color:#B45EA4\">const</span><span> sampler_mask &amp; mask)\n</span>}\n<!-- -->\n</code></pre></pre><p class=\"css-0\">the <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">chrome</div> template argument is enum with the following values:</p><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\"><style data-emotion=\"css 1kc89wa\">.css-1kc89wa{color:purple.500;}</style><a class=\"chakra-link css-1kc89wa\" href=\"#\">chrome_mode::red_channel</a> - use the red channel as a mask of <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">sampler_mask</div> </li><li class=\"css-b0qdn7\"><a class=\"chakra-link css-1kc89wa\" href=\"#\">chrome_mode::green_channel</a> - use the green channel as a mask of <div class=\"css-qskmz3\">sampler_mask</div> </li><li class=\"css-b0qdn7\"><a class=\"chakra-link css-1kc89wa\" href=\"#\">chrome_mode::blue_channel</a> - use the blue channel as a mask of <div class=\"css-qskmz3\">sampler_mask</div> </li><li class=\"css-b0qdn7\"><a class=\"chakra-link css-1kc89wa\" href=\"#\">chrome_mode::alpha_channel</a> - use the alpha channel as a mask of <div class=\"css-qskmz3\">sampler_mask</div> </li><li class=\"css-b0qdn7\"><a class=\"chakra-link css-1kc89wa\" href=\"#\">chrome_mode::red_channel_inverted</a> - use the inverted red channel</li><li class=\"css-b0qdn7\"><a class=\"chakra-link css-1kc89wa\" href=\"#\">chrome_mode::green_channel_inverted</a> - use the inverted green channel</li><li class=\"css-b0qdn7\"><a class=\"chakra-link css-1kc89wa\" href=\"#\">chrome_mode::blue_channel_inverted</a> - use the inverted blue channel</li><li class=\"css-b0qdn7\"><a class=\"chakra-link css-1kc89wa\" href=\"#\">chrome_mode::alpha_channel_inverted</a> - use the inverted alpha channel</li></ul><img src=\"/images/sampler_masking.png\" style=\"height:250px;margin:auto\"/><h3 class=\"css-0\">8. Checker Board Sampler</h3><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">defined at <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">&lt;microgl/samplers/checker_board.h&gt;</div></li><li class=\"css-b0qdn7\">example at <div class=\"css-qskmz3\">/examples/example_sampler_checkerboard.cpp</div></li></ul><p class=\"css-0\">This sampler can draw a checker board pattern with</p><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">Configurable two colors</li><li class=\"css-b0qdn7\">Configurable horizontal and vertical splits</li></ul><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\">  * checker board pattern sampler\n</span><span class=\"hljs-function\">  *\n</span><span class=\"hljs-function\">  * @tparam rgba_ the rgba info\n</span><span style=\"color:#B6B18B\">  */</span><span>\n</span><span></span><span style=\"color:#B45EA4\">template</span><span>&lt;</span><span style=\"color:#B45EA4\">typename</span><span> rgba_=</span><span style=\"color:#B45EA4\">rgba_t</span><span>&lt;</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">8</span><span>,</span><span style=\"color:#E7CE56\">0</span><span>&gt;&gt;\n</span>struct checker_board {\n<span>    </span><span style=\"color:#B45EA4\">using</span><span> rgba = rgba_;\n</span>    \n<span>    </span><span style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\">      * constructor\n</span><span class=\"hljs-function\">      *\n</span><span class=\"hljs-function\">      * @param color1 1st color\n</span><span class=\"hljs-function\">      * @param color2 2nd color\n</span><span class=\"hljs-function\">      * @param horizontal horizontal splits count\n</span><span class=\"hljs-function\">      * @param vertical vertical split count\n</span><span style=\"color:#B6B18B\">      */</span><span>\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">explicit</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">checker_board</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp; color1,\n</span><span class=\"hljs-function\" style=\"color:#E7CE56\">                            </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp; color2,\n</span><span class=\"hljs-function\" style=\"color:#E7CE56\">                            </span><span class=\"hljs-function\" style=\"color:#B45EA4\">unsigned</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> horizontal=</span><span class=\"hljs-function\" style=\"color:#E7CE56\">2</span><span class=\"hljs-function\" style=\"color:#E7CE56\">,\n</span><span class=\"hljs-function\" style=\"color:#E7CE56\">                            </span><span class=\"hljs-function\" style=\"color:#B45EA4\">unsigned</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> vertical=</span><span class=\"hljs-function\" style=\"color:#E7CE56\">2</span><span class=\"hljs-function\" style=\"color:#E7CE56\">)</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    }\n</span><span class=\"hljs-function\">\n</span></code></pre></pre><img src=\"/images/sampler_checker_board.png\" style=\"height:250px;margin:auto\"/><h2 class=\"css-0\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">microgl::sampling</div> namespace</h2><p class=\"css-0\">This namespace also defines the following utility methods</p><h3 class=\"css-0\">sample from another number system</h3><p class=\"css-0\">sample uv coords from sampler with a different number system.\nThis is handy because samplers work in quantized space to be more\nefficient and sometimes it is not convenient. This method will convert\nthe uv coords into fixed points and then sample from the sampler.</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B6B18B\">/**\n</span><span style=\"color:#B6B18B\">* @tparam Sampler the sampler type\n</span><span style=\"color:#B6B18B\">* @tparam number the number type\n</span><span style=\"color:#B6B18B\">* \n</span><span style=\"color:#B6B18B\">* @param sampler the sampler reference \n</span><span style=\"color:#B6B18B\">* @param u the u coord\n</span><span style=\"color:#B6B18B\">* @param v the v coord\n</span><span style=\"color:#B6B18B\">* @param p precision can be {low, medium, high, amazing}\n</span><span style=\"color:#B6B18B\">* @param output output color\n</span><span style=\"color:#B6B18B\">*/</span><span>\n</span><span></span><span class=\"hljs-function\" style=\"color:#B45EA4\">template</span><span class=\"hljs-function\">&lt;class Sampler, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">typename</span><span class=\"hljs-function\"> number&gt;\n</span><span class=\"hljs-function\"></span><span class=\"hljs-function\" style=\"color:#B45EA4\">inline</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">sample</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> Sampler &amp; sampler,\n</span><span class=\"hljs-function\" style=\"color:#E7CE56\">                   </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> number &amp;u, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> number &amp;v,\n</span><span class=\"hljs-function\" style=\"color:#E7CE56\">                   </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">enum</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> microgl::precision &amp;p,\n</span><span class=\"hljs-function\" style=\"color:#E7CE56\">                   </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp;output)</span><span class=\"hljs-function\"> </span><span>{\n</span>\n</code></pre></pre><h3 class=\"css-0\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">base_sampler</div> class</h3><p class=\"css-0\">You can extend this class to include other utility methods inside your class.\nThis is a nice container, that can wrap samplers and also invoke their sampling\nbehaviour via <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">crpt</div> compile-time polymorphism. I prefer not to use it because it\nmakes the definition a bit combersome and long with <div class=\"css-qskmz3\">c++</div> templates quirks </p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-class\">* @tparam rgba_ the rgba_t info type\n</span><span class=\"hljs-class\">* @tparam impl the type of the derived class\n</span><span style=\"color:#B6B18B\">*/</span><span>\n</span><span></span><span style=\"color:#B45EA4\">template</span><span>&lt;</span><span style=\"color:#B45EA4\">typename</span><span> rgba_, </span><span style=\"color:#B45EA4\">typename</span><span> impl&gt;\n</span><span></span><span class=\"hljs-class\" style=\"color:#B45EA4\">class</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">base_sampler</span><span class=\"hljs-class\">\n</span><span class=\"hljs-class\">\n</span></code></pre></pre>","scope":{}},"frontMatter":{},"document":{"name":"docs","groups":[{"title":"Getting Started","items":[{"title":"Setup","route":"getting-started/setup","path":"content/docs/setup.mdx"},{"title":"Features","route":"getting-started/features","path":"content/docs/features.mdx"}]},{"title":"Concepts","items":[{"title":"Numbers","route":"concepts/numbers","path":"content/docs/numbers.mdx"},{"title":"Math","route":"concepts/math","path":"content/docs/math.mdx"},{"title":"RGBA","route":"concepts/rgba","path":"content/docs/rgba.mdx"},{"title":"Pixel Coders","route":"concepts/pixel-coders","path":"content/docs/pixel-coders.mdx"},{"title":"Samplers","route":"concepts/samplers","path":"content/docs/samplers.mdx"},{"title":"Composition","route":"concepts/composition","path":"content/docs/composition.mdx"},{"title":"Bitmaps","route":"concepts/bitmaps","path":"content/docs/bitmaps.mdx"},{"title":"3D Shaders","route":"concepts/3d","path":"content/docs/3d.mdx"},{"title":"Canvas","route":"concepts/canvas","path":"content/docs/canvas.mdx"}]},{"title":"Drawing","items":[{"title":"Rectangles","route":"drawing/rectangles","path":"content/docs/rectangles.mdx"},{"title":"Rounded Shapes","route":"drawing/rounded","path":"content/docs/rounded.mdx"},{"title":"Quadrilaterals","route":"drawing/quadrilaterals","path":"content/docs/quadrilaterals.mdx"},{"title":"Triangle","route":"drawing/triangle","path":"content/docs/triangle.mdx"},{"title":"Triangle Batches","route":"drawing/triangle-batches","path":"content/docs/triangle-batches.mdx"},{"title":"Polygons","route":"drawing/polygons","path":"content/docs/polygons.mdx"},{"title":"Masks","route":"drawing/masks","path":"content/docs/masks.mdx"},{"title":"Path Fills","route":"drawing/path-fills","path":"content/docs/path-fills.mdx"},{"title":"Path Strokes","route":"drawing/path-stroke","path":"content/docs/path-stroke.mdx"},{"title":"Bezier Patches","route":"drawing/bezier-patches","path":"content/docs/patches.mdx"},{"title":"Lines","route":"drawing/lines","path":"content/docs/lines.mdx"},{"title":"Text","route":"drawing/text","path":"content/docs/text.mdx"},{"title":"Gradients","route":"drawing/gradients","path":"content/docs/gradients.mdx"},{"title":"More Samplers","route":"drawing/more-samplers","path":"content/docs/more-samplers.mdx"},{"title":"3D","route":"drawing/3d","path":"content/docs/draw-3d.mdx"}]},{"title":"Geometry","items":[{"title":"Intro","route":"geometry/intro","path":"content/docs/wip.mdx"}]}],"__map":{"getting-started/setup":"content/docs/setup.mdx","getting-started/features":"content/docs/features.mdx","concepts/numbers":"content/docs/numbers.mdx","concepts/math":"content/docs/math.mdx","concepts/rgba":"content/docs/rgba.mdx","concepts/pixel-coders":"content/docs/pixel-coders.mdx","concepts/samplers":"content/docs/samplers.mdx","concepts/composition":"content/docs/composition.mdx","concepts/bitmaps":"content/docs/bitmaps.mdx","concepts/3d":"content/docs/3d.mdx","concepts/canvas":"content/docs/canvas.mdx","drawing/rectangles":"content/docs/rectangles.mdx","drawing/rounded":"content/docs/rounded.mdx","drawing/quadrilaterals":"content/docs/quadrilaterals.mdx","drawing/triangle":"content/docs/triangle.mdx","drawing/triangle-batches":"content/docs/triangle-batches.mdx","drawing/polygons":"content/docs/polygons.mdx","drawing/masks":"content/docs/masks.mdx","drawing/path-fills":"content/docs/path-fills.mdx","drawing/path-stroke":"content/docs/path-stroke.mdx","drawing/bezier-patches":"content/docs/patches.mdx","drawing/lines":"content/docs/lines.mdx","drawing/text":"content/docs/text.mdx","drawing/gradients":"content/docs/gradients.mdx","drawing/more-samplers":"content/docs/more-samplers.mdx","drawing/3d":"content/docs/draw-3d.mdx","geometry/intro":"content/docs/wip.mdx"}}}},"__N_SSG":true}