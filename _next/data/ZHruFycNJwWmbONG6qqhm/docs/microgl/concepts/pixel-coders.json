{"pageProps":{"data":{"logo":"/logos//microgl-512-logo.png","slug":"concepts/pixel-coders","content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    code: \"code\",\n    h2: \"h2\",\n    strong: \"strong\",\n    pre: \"pre\",\n    br: \"br\",\n    blockquote: \"blockquote\",\n    em: \"em\",\n    ul: \"ul\",\n    li: \"li\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Introduction\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Pixel coders are objects that can encode color or intensity into pixel representation\\nand also decode a pixel into a color.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"microgl\"\n      }), \" can support any color configuration and any pixel format you can think of.\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"How to define pixel coder\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. Implement the basic interface\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"at it's simplest form, you have to implement the following interface. the struct/class have to be\\n\", _jsx(_components.strong, {\n        children: \"default constructable\"\n      }), \".\\nhere is a basic pixel coder, that encodes \", _jsx(_components.strong, {\n        children: \"RGB\"\n      }), \" 8-bit color channels into a packed\\n32 bit integer. This is the minimal interface you have to implement to have a pixel coder.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"#include <microgl/rgba.h>\\n\\nstruct RGB888_PACKED_32 {\\n    using rgba = rgba_t<8, 8, 8, 0>; // rgba info\\n    using pixel = uint32_t; // pixel type\\n\\n    // these methods can be static if they do not access any variable\\n    // this encodes a color object into a pixel of type uint32_t\\n    inline void encode(const color_t &input, pixel &output) const {\\n        output = (input.r << 16) + (input.g << 8) + input.b;\\n    }\\n\\n    // this decodes a uint32_t integer into a color object\\n    inline void decode(const pixel &input, color_t &output) const {\\n        output.r = (input & 0x00FF0000) >> 16;\\n        output.g = (input & 0x0000FF00) >> 8;\\n        output.b = (input & 0x000000FF);\\n    }\\n\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [\"2. instantiate the \", _jsx(_components.code, {\n        children: \"RGBA_PACKED\"\n      }), \" template\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"this template is a generic and simple way to define a pixel coder, that can be packed\\ninside the smallest fitting integer type. you can also define the ordering of the channels.\\nat it's simplest, the signature of the template is:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"// defined at <microgl/pixel_coders/RGBA_PACKED.h>\\ntemplate<u8 r, u8 g, u8 b, u8 a=0, u8 ri=0, u8 gi=1, u8 bi=2, u8 ai=3>\\nstruct RGBA_PACKED { \\n    // the rgba info is here\\n    using rgba = rgba_t<r, g, b, a>;\\n    // the pixel type is here\\n    using pixel = ... // will automatically be uint8_t, uint16_t, uint32_t, uint64_t\\n    ... \\n    ... \\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"the \", _jsx(_components.code, {\n        children: \"r/g/b/a\"\n      }), \" template arguments are used to define the bit depth of the color channels.\", _jsx(_components.br, {}), \"\\n\", \"while the \", _jsx(_components.code, {\n        children: \"ri/gi/bi/ai\"\n      }), \" template arguments are used to define the ordering of the channels\\nso you can be flexible about the layout. here is an example, you can use:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"#include <microgl/pixel_coders/RGBA_PACKED.h>\\n\\nusing RGB_565 = RGBA_PACKED<5, 6, 5, 0>;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [\"3. Instantiate the \", _jsx(_components.code, {\n        children: \"RGBA_UNPACKED\"\n      }), \" template\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"the \", _jsx(_components.code, {\n        children: \"RGBA_UNPACKED\"\n      }), \" struct defines a trivial pixel coder, that encodes the color into an array,\\nthe array size is inferred at compile-time according to non-zero channels. it's signature\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"// defined at <microgl/pixel_coders/RGBA_PACKED.h>\\ntemplate<uint8_t r, uint8_t g, uint8_t b, uint8_t a, bool delete_zero_channel=true>\\nstruct RGBA_UNPACKED {\\n    using rgba = rgba_t<r,g,b,a>;\\n    using pixel = array<count> ;\\n    static constexpr uint8_t count;\\n    ...\\n    ...\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"you can use this coder simply with\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"#include <microgl/pixel_coders/RGBA_UNPACKED.h>\\n\\nusing RGB_888 = RGBA_UNPACKED<8, 8, 8, 0>;\\n// the inferred pixel type which is an array\\nusing pixel = typename RGB_888::pixel;\\npixel output;\\n// encode a color object into 8 bits array\\nRGB_888::encode({31, 63, 31}, output)\\n\\nuint8_t r = output.data[0];\\nuint8_t g = output.data[1];\\nuint8_t b = output.data[2];\\n// now let's decode\\ncolor_t decoded_color;\\nRGB_888::decode(output, decoded_color);\\n\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"using the \", _jsx(_components.code, {\n        children: \"RGBA_UNPACKED\"\n      }), \" can save memory if you have an \", _jsx(_components.code, {\n        children: \"rgba=(8,8,8,0)\"\n      }), \", in which case\\nthey are better suited to be stored in a 3 element array rather than a packed a \", _jsx(_components.code, {\n        children: \"uint32_t\"\n      }), \"\\ntype (using a packed \", _jsx(_components.code, {\n        children: \"uint32_t\"\n      }), \" will have a wasted byte).\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [\"4. extend the \", _jsx(_components.code, {\n        children: \"pixel_coder\"\n      }), \" class\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"you can also extend \", _jsx(_components.code, {\n        children: \"pixel_coder\"\n      }), \" class defined at \", _jsx(_components.code, {\n        children: \"<microgl/pixel_coder.h>\"\n      }), \".\\nusing this can boost your pixel coder with extra utility methods, it uses compile-time\\ninheritance via \", _jsx(_components.code, {\n        children: \"crpt\"\n      }), \" design pattern, but it will cause your class to be less compact,\\nbecause of template issues.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"5. use prebuilt pixel coders\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"out of the box, \", _jsx(_components.strong, {\n          children: '<microgl/pixel_coders>'\n        }), \" is packed with the following pixel coders for your conveniance\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"True color coders (32 bit coders)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"for pixels stored in a \", _jsx(_components.em, {\n        children: \"4 bytes\"\n      }), \" data structure\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"RGB888_PACKED_32.h\"\n        }), \" - \", _jsx(_components.strong, {\n          children: \"rgb(8|8|8)\"\n        }), \" channels into a 32 bit unsigned integer\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"RGBA8888_PACKED_32.h\"\n        }), \" - \", _jsx(_components.strong, {\n          children: \"rgba(8|8|8|8)\"\n        }), \" channels into a 32 bit unsigned integer\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"RGBA8888_ARRAY.h\"\n        }), \" - \", _jsx(_components.strong, {\n          children: \"rgba(8|8|8|8)\"\n        }), \" channels into array (faster io)\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"RGB888_ARRAY.h\"\n        }), \" - \", _jsx(_components.strong, {\n          children: \"rgb(8|8|8)\"\n        }), \" channels into array (faster io)\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"16 bit coders\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"for pixels stored in a \", _jsx(_components.em, {\n        children: \"2 bytes\"\n      }), \" data structure\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"RGB555_PACKED_16.h\"\n        }), \" - \", _jsx(_components.strong, {\n          children: \"rgb(5|5|5)\"\n        }), \" channels into a 16 bits unsigned integer (word)\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"RGB565_PACKED_16.h\"\n        }), \" - \", _jsx(_components.strong, {\n          children: \"rgb(5|6|5)\"\n        }), \" channels into a 16 bits unsigned integer (word)\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"RGBA4444_PACKED_16.h\"\n        }), \" - \", _jsx(_components.strong, {\n          children: \"rgba(4|4|4|4)\"\n        }), \" channels into a 16 bits unsigned integer (word)\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"RGBA5551_PACKED_16.h\"\n        }), \" - \", _jsx(_components.strong, {\n          children: \"rgba(5|5|5|1)\"\n        }), \" channels into a 16 bits unsigned integer (word)\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"ARGB1555_PACKED_16.h\"\n        }), \" - \", _jsx(_components.strong, {\n          children: \"argb(1|5|5|5)\"\n        }), \" channels into a 16 bits unsigned integer (word)\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"8 bit coders\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"for pixels stored in a \", _jsx(_components.em, {\n        children: \"1 bytes\"\n      }), \" data structure\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"RGB332_PACKED_8.h\"\n        }), \" - \", _jsx(_components.strong, {\n          children: \"rgb(3|3|2)\"\n        }), \" channels into a 8 bits unsigned integer (char)\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Memory friendly coders\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"the following coders are very handy for packed bitmaps, they also use a lookup table for\\nfast conversions\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: _jsx(_components.code, {\n            children: \"BPP_RGBA.h\"\n          })\n        }), \" - this will map/scale 1,2,4,8 bits pixel to a defined alpha channel bits, rgb values will stay\\nfixed on maximum value. Uses a single lookup table only if needed at compile time. Good for optimized bitmap fonts.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"BPP_RGB.h\"\n        }), \" - this will map 1,2,4,8 bits to predefined RGB channels bits, uses\\n3 lookup tables only if needed. Alpha channel is discarded.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"BPP_1_RGB.h\"\n        }), \" - 1 bit channel (2 colors) scaled into any rgb depth\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"BPP_2_RGB.h\"\n        }), \" - 2 bit channel (4 colors) scaled into any rgb depth\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"BPP_4_RGB.h\"\n        }), \" - 4 bit channel (16 colors) scaled into any rgb depth\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"BPP_8_RGB.h\"\n        }), \" - 8 bit channel (256 colors) scaled into any rgb depth\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"BPP_1_RGBA.h\"\n        }), \" - 1 bit channel (2 colors) scaled into any rgba depth\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"BPP_2_RGBA.h\"\n        }), \" - 2 bit channel (4 colors) scaled into any rgba depth\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"BPP_4_RGBA.h\"\n        }), \" - 4 bit channel (16 colors) scaled into any rgba depth\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"BPP_8_RGBA.h\"\n        }), \" - 8 bit channel (256 colors) scaled into any rgba depth\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Special Coders\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"this coders can transform a coder to another rgba depth\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"coder_rgba.h\"\n        }), \" - convert a given coder to a different rgba color depth\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"coder_converter.h\"\n        }), \" - convert one coder to the color depth of another coder\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"GRAYSCALE.h\"\n        }), \" - a pixel coder template, that saves one channel, also supports alpha channel\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"SINGLE.h\"\n        }), \" - defines 4 single channel pixel coders structs \", _jsx(_components.code, {\n          children: \"R\"\n        }), \", \", _jsx(_components.code, {\n          children: \"G\"\n        }), \", \", _jsx(_components.code, {\n          children: \"B\"\n        }), \", \", _jsx(_components.code, {\n          children: \"A\"\n        }), \" literaly\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [_jsx(_components.code, {\n        children: \"microgl::coder\"\n      }), \" namespace\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"encode intensity into a pixel with a pixel coder\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"/**\\n* encode intensity into a pixel with a pixel coder\\n*\\n* @tparam number underlying intensity number type\\n* @tparam Coder the pixel coder type to use\\n*\\n* @param input input intensity\\n* @param output output pixel\\n* @param $coder the coder reference\\n*/\\ntemplate <typename number, class Coder>\\nvoid inline\\nencode(const intensity<number> &input, typename Coder::pixel &output, const Coder & $coder)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"decode pixel into intensity using a coder\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"/**\\n* decode pixel into intensity using a coder\\n*\\n* @tparam number underlying intensity number type\\n* @tparam Coder the pixel coder type to use\\n*\\n* @param input input pixel\\n* @param output output intensity\\n* @param $coder the coder reference\\n*/\\ntemplate <typename number, class Coder>\\nvoid decode(const typename Coder::pixel &input, intensity<number> &output, const Coder & $coder) {\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      children: [_jsx(_components.code, {\n        children: \"pixel_coder\"\n      }), \" class\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"a base pixel coder that can boost your pixel coder with extra utilities.\\ninheritance is via crpt design pattern.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-lang=cpp\",\n        children: \"/**\\n*\\n* @tparam pixel_ the pixel storage type\\n* @tparam rgba_ the {rgba_t} info object\\n* @tparam impl the type of the derived class\\n*/\\ntemplate<typename pixel_, typename rgba_, typename impl>\\nclass pixel_coder : public crpt<impl> {\\n    using pixel= pixel_;\\n    using rgba= rgba_;\\n\\n    // this will encode in your derived class\\n    void encode(const color_t &input, pixel &output) const\\n    // this will decode in your derived class\\n    void decode(const pixel &input, color_t &output) const\\n\\n    /**\\n    * encode intensity to pixel of the coder\\n    *\\n    * @tparam number underlying intensity number type\\n    *\\n    * @param input input intensity\\n    * @param output output pixel\\n    */\\n    template <typename number>\\n    void encode(const intensity<number> &input, pixel &output) const\\n\\n    /**\\n    * decode pixel into intensity\\n    *\\n    * @tparam number underlying intensity number type\\n    *\\n    * @param input input pixel\\n    * @param output output intensity\\n    */\\n    template <typename number>\\n    void decode(const pixel &input, intensity<number> &output) const\\n\\n    /**\\n    * convert intensity to color of space defined but this coder\\n    *\\n    * @tparam number underlying intensity number type\\n    * @param input intensity\\n    * @param output color\\n    */\\n    template <typename number>\\n    void convert(const intensity<number> &input, color_t &output) const\\n\\n    /**\\n    * convert color to intensity\\n    *\\n    * @tparam number underlying intensity number type\\n    *\\n    * @param input color\\n    * @param output intensity\\n    */\\n    template <typename number>\\n    void convert(const color_t &input, intensity<number> &output) const\\n\\n    /**\\n    * convert a color of this coder space into a space of another coder\\n    *\\n    * @tparam CODER2 the other coder\\n    *\\n    * @param input color\\n    * @param output color output\\n    */\\n    template<typename CODER2>\\n    void convert(const color_t &input, color_t &output) const\\n    /**\\n    * convert a pixel from this coder to a pixel of another coder\\n    *\\n    * @tparam CODER2 the other coder\\n    *\\n    * @param input input pixel of my coder\\n    * @param output the output pixel\\n    * @param coder2 the other coder reference\\n    */\\n    template<typename CODER2>\\n    void convert(const pixel &input, typename CODER2::pixel &output, const CODER2 &coder2) const\\n\\n}\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"frontMatter":{},"document":{"name":"docs","logo":"/logos//microgl-512-logo.png","groups":[{"title":"Getting Started","items":[{"title":"Setup","route":"getting-started/setup","path":"content/docs/microgl/setup.mdx"},{"title":"Features","route":"getting-started/features","path":"content/docs/microgl/features.mdx"}]},{"title":"Concepts","items":[{"title":"Numbers","route":"concepts/numbers","path":"content/docs/microgl/numbers.mdx"},{"title":"Math","route":"concepts/math","path":"content/docs/microgl/math.mdx"},{"title":"RGBA","route":"concepts/rgba","path":"content/docs/microgl/rgba.mdx"},{"title":"Pixel Coders","route":"concepts/pixel-coders","path":"content/docs/microgl/pixel-coders.mdx"},{"title":"Samplers","route":"concepts/samplers","path":"content/docs/microgl/samplers.mdx"},{"title":"Composition","route":"concepts/composition","path":"content/docs/microgl/composition.mdx"},{"title":"Bitmaps","route":"concepts/bitmaps","path":"content/docs/microgl/bitmaps.mdx"},{"title":"3D Shaders","route":"concepts/3d","path":"content/docs/microgl/3d.mdx"},{"title":"Canvas","route":"concepts/canvas","path":"content/docs/microgl/canvas.mdx"}]},{"title":"Drawing","items":[{"title":"Rectangles","route":"drawing/rectangles","path":"content/docs/microgl/rectangles.mdx"},{"title":"Rounded Shapes","route":"drawing/rounded","path":"content/docs/microgl/rounded.mdx"},{"title":"Quadrilaterals","route":"drawing/quadrilaterals","path":"content/docs/microgl/quadrilaterals.mdx"},{"title":"Triangle","route":"drawing/triangle","path":"content/docs/microgl/triangle.mdx"},{"title":"Triangle Batches","route":"drawing/triangle-batches","path":"content/docs/microgl/triangle-batches.mdx"},{"title":"Polygons","route":"drawing/polygons","path":"content/docs/microgl/polygons.mdx"},{"title":"Masks","route":"drawing/masks","path":"content/docs/microgl/masks.mdx"},{"title":"Path Fills","route":"drawing/path-fills","path":"content/docs/microgl/path-fills.mdx"},{"title":"Path Strokes","route":"drawing/path-stroke","path":"content/docs/microgl/path-stroke.mdx"},{"title":"Bezier Patches","route":"drawing/bezier-patches","path":"content/docs/microgl/patches.mdx"},{"title":"Lines","route":"drawing/lines","path":"content/docs/microgl/lines.mdx"},{"title":"Text","route":"drawing/text","path":"content/docs/microgl/text.mdx"},{"title":"Gradients","route":"drawing/gradients","path":"content/docs/microgl/gradients.mdx"},{"title":"More Samplers","route":"drawing/more-samplers","path":"content/docs/microgl/more-samplers.mdx"},{"title":"3D","route":"drawing/3d","path":"content/docs/microgl/draw-3d.mdx"}]}],"__map":{"getting-started/setup":"content/docs/microgl/setup.mdx","getting-started/features":"content/docs/microgl/features.mdx","concepts/numbers":"content/docs/microgl/numbers.mdx","concepts/math":"content/docs/microgl/math.mdx","concepts/rgba":"content/docs/microgl/rgba.mdx","concepts/pixel-coders":"content/docs/microgl/pixel-coders.mdx","concepts/samplers":"content/docs/microgl/samplers.mdx","concepts/composition":"content/docs/microgl/composition.mdx","concepts/bitmaps":"content/docs/microgl/bitmaps.mdx","concepts/3d":"content/docs/microgl/3d.mdx","concepts/canvas":"content/docs/microgl/canvas.mdx","drawing/rectangles":"content/docs/microgl/rectangles.mdx","drawing/rounded":"content/docs/microgl/rounded.mdx","drawing/quadrilaterals":"content/docs/microgl/quadrilaterals.mdx","drawing/triangle":"content/docs/microgl/triangle.mdx","drawing/triangle-batches":"content/docs/microgl/triangle-batches.mdx","drawing/polygons":"content/docs/microgl/polygons.mdx","drawing/masks":"content/docs/microgl/masks.mdx","drawing/path-fills":"content/docs/microgl/path-fills.mdx","drawing/path-stroke":"content/docs/microgl/path-stroke.mdx","drawing/bezier-patches":"content/docs/microgl/patches.mdx","drawing/lines":"content/docs/microgl/lines.mdx","drawing/text":"content/docs/microgl/text.mdx","drawing/gradients":"content/docs/microgl/gradients.mdx","drawing/more-samplers":"content/docs/microgl/more-samplers.mdx","drawing/3d":"content/docs/microgl/draw-3d.mdx"}}}},"__N_SSG":true}