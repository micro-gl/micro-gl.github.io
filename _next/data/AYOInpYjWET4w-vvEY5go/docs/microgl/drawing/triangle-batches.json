{"pageProps":{"data":{"slug":"drawing/triangle-batches","content":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Introduction\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Triangles Batches\"), \" are supported in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"microgl\"), \". This is a convenient way to draw\\nmany triangles with \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/docs/concepts/samplers\"\n  }, \"samplers\"), \", \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/docs/drawing/3d\"\n  }, \"3d-shaders\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Wireframes\"), \".\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Example at \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"/examples/example_draw_triangle.cpp\")))), mdx(\"img\", {\n    src: \"/images/canvas_polygon.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"p\", null, \"WIP\"), mdx(\"h1\", null, \"Vertices buffer\"), mdx(\"p\", null, \"WIP\"), mdx(\"h1\", null, \"Indices buffer and type\"), mdx(\"p\", null, \"WIP\"), mdx(\"h1\", null, \"Boundary buffer\"), mdx(\"p\", null, \"WIP\"), mdx(\"h1\", null, \"Usage Example\"), mdx(\"p\", null, \"WIP\"), mdx(\"p\", null, \"WIP\"), mdx(\"h1\", null, \"Signature API\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"/**\\n * @tparam bitmap_type  the bitmap type\\n * @tparam options      the options bitset\\n */\\ntemplate<typename bitmap_type, uint8_t options=CANVAS_OPT_default>\\nclass canvas {\\npublic:\\n    /**\\n     * Draw 2d triangle batches. Given:\\n     * - vertex buffer, indices buffer, indices type, draw triangles.\\n     * - uvs are optional, and if are nullptr, the method will compute them alone.\\n     * - indices buffer are optional, and if are nullptr, the method will use vertex buffer as is.\\n     *\\n     * Supported batch strategies are:\\n     * - TRIANGLES - every 3 indices for a triangle\\n     * - FAN - the first index forms with every 2 other indices\\n     * - STRIP - the best for low memory when possible\\n     *\\n     * Indices array point to the vertex array and is an important concept, when you want\\n     * to draw a subset of vertices, or to construct triangles from a set of vertices\\n     *\\n     * @tparam BlendMode        the blend mode struct\\n     * @tparam PorterDuff       the alpha compositing struct\\n     * @tparam antialias        antialiasing flag\\n     * @tparam number1          number type of position\\n     * @tparam number2          number type of uv coords\\n     * @tparam Sampler1         sampler type for fill\\n     * @tparam Sampler2         sampler type for stroke\\n     *\\n     * @param sampler           fill sampler reference\\n     * @param transform         3x3 matrix transformation\\n     * @param vertices          pointer to points array\\n     * @param uvs               (Optional) pointer to uv array\\n     * @param indices           (Optional) pointer to indices array\\n     * @param boundary_buffer   (Optional) pointer to boundary buffer, used in quick anti-aliasing\\n     * @param size              size of indices buffer\\n     * @param type              type of indices buffer {TRIANGLES, FAN, TRIANGLES_STRIP}\\n     * @param opacity           opacity [0..255]\\n     * @param u0                uv coord\\n     * @param v0                uv coord\\n     * @param u1                uv coord\\n     * @param v1                uv coord\\n     */\\n    template<typename BlendMode=blendmode::Normal, \\n             typename PorterDuff=porterduff::FastSourceOverOnOpaque,\\n             bool antialias=false, \\n             typename number1=float, typename number2=float, \\n             typename Sampler>\\n    void drawTriangles(const Sampler & sampler,\\n                       const matrix_3x3<number1> &transform,\\n                       const vec2<number1> * vertices= nullptr,\\n                       const vec2<number2> * uvs=nullptr,\\n                       const index * indices= nullptr,\\n                       const boundary_info * boundary_buffer= nullptr,\\n                       index size=0,\\n                       enum indices type=indices::TRIANGLES,\\n                       opacity_t opacity=255,\\n                       const number2 &u0=number2(0), const number2 &v0=number2(1),\\n                       const number2 &u1=number2(1), const number2 &v1=number2(0));\\n\\n\")));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<h1 class=\"css-0\">Introduction</h1><p class=\"css-0\"><style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">Triangles Batches</strong> are supported in <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">microgl</div>. This is a convenient way to draw\nmany triangles with <style data-emotion=\"css 1kc89wa\">.css-1kc89wa{color:purple.500;}</style><a class=\"chakra-link css-1kc89wa\" href=\"/docs/concepts/samplers\">samplers</a>, <a class=\"chakra-link css-1kc89wa\" href=\"/docs/drawing/3d\">3d-shaders</a> and <strong class=\"css-10ircq3\">Wireframes</strong>.</p><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">Example at <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">/examples/example_draw_triangle.cpp</div></strong></p></blockquote><img src=\"/images/canvas_polygon.png\" style=\"height:250px;margin:auto\"/><p class=\"css-0\">WIP</p><h1 class=\"css-0\">Vertices buffer</h1><p class=\"css-0\">WIP</p><h1 class=\"css-0\">Indices buffer and type</h1><p class=\"css-0\">WIP</p><h1 class=\"css-0\">Boundary buffer</h1><p class=\"css-0\">WIP</p><h1 class=\"css-0\">Usage Example</h1><p class=\"css-0\">WIP</p><p class=\"css-0\">WIP</p><h1 class=\"css-0\">Signature API</h1><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B6B18B\">/**\n</span><span style=\"color:#B6B18B\"> * @tparam bitmap_type  the bitmap type\n</span><span style=\"color:#B6B18B\"> * @tparam options      the options bitset\n</span><span style=\"color:#B6B18B\"> */</span><span>\n</span><span></span><span style=\"color:#B45EA4\">template</span><span>&lt;</span><span style=\"color:#B45EA4\">typename</span><span> bitmap_type, </span><span style=\"color:#B45EA4\">uint8_t</span><span> options=CANVAS_OPT_default&gt;\n</span>class canvas {\n<span></span><span style=\"color:#B45EA4\">public</span><span>:\n</span><span>    </span><span style=\"color:#B6B18B\">/**\n</span><span style=\"color:#B6B18B\">     * Draw 2d triangle batches. Given:\n</span><span style=\"color:#B6B18B\">     * - vertex buffer, indices buffer, indices type, draw triangles.\n</span><span style=\"color:#B6B18B\">     * - uvs are optional, and if are nullptr, the method will compute them alone.\n</span><span style=\"color:#B6B18B\">     * - indices buffer are optional, and if are nullptr, the method will use vertex buffer as is.\n</span><span style=\"color:#B6B18B\">     *\n</span><span style=\"color:#B6B18B\">     * Supported batch strategies are:\n</span><span style=\"color:#B6B18B\">     * - TRIANGLES - every 3 indices for a triangle\n</span><span style=\"color:#B6B18B\">     * - FAN - the first index forms with every 2 other indices\n</span><span style=\"color:#B6B18B\">     * - STRIP - the best for low memory when possible\n</span><span style=\"color:#B6B18B\">     *\n</span><span style=\"color:#B6B18B\">     * Indices array point to the vertex array and is an important concept, when you want\n</span><span style=\"color:#B6B18B\">     * to draw a subset of vertices, or to construct triangles from a set of vertices\n</span><span style=\"color:#B6B18B\">     *\n</span><span style=\"color:#B6B18B\">     * @tparam BlendMode        the blend mode struct\n</span><span style=\"color:#B6B18B\">     * @tparam PorterDuff       the alpha compositing struct\n</span><span style=\"color:#B6B18B\">     * @tparam antialias        antialiasing flag\n</span><span style=\"color:#B6B18B\">     * @tparam number1          number type of position\n</span><span style=\"color:#B6B18B\">     * @tparam number2          number type of uv coords\n</span><span style=\"color:#B6B18B\">     * @tparam Sampler1         sampler type for fill\n</span><span style=\"color:#B6B18B\">     * @tparam Sampler2         sampler type for stroke\n</span><span style=\"color:#B6B18B\">     *\n</span><span style=\"color:#B6B18B\">     * @param sampler           fill sampler reference\n</span><span style=\"color:#B6B18B\">     * @param transform         3x3 matrix transformation\n</span><span style=\"color:#B6B18B\">     * @param vertices          pointer to points array\n</span><span style=\"color:#B6B18B\">     * @param uvs               (Optional) pointer to uv array\n</span><span style=\"color:#B6B18B\">     * @param indices           (Optional) pointer to indices array\n</span><span style=\"color:#B6B18B\">     * @param boundary_buffer   (Optional) pointer to boundary buffer, used in quick anti-aliasing\n</span><span style=\"color:#B6B18B\">     * @param size              size of indices buffer\n</span><span style=\"color:#B6B18B\">     * @param type              type of indices buffer {TRIANGLES, FAN, TRIANGLES_STRIP}\n</span><span style=\"color:#B6B18B\">     * @param opacity           opacity [0..255]\n</span><span style=\"color:#B6B18B\">     * @param u0                uv coord\n</span><span style=\"color:#B6B18B\">     * @param v0                uv coord\n</span><span style=\"color:#B6B18B\">     * @param u1                uv coord\n</span><span style=\"color:#B6B18B\">     * @param v1                uv coord\n</span><span style=\"color:#B6B18B\">     */</span><span>\n</span><span>    </span><span style=\"color:#B45EA4\">template</span><span>&lt;</span><span style=\"color:#B45EA4\">typename</span><span> BlendMode=blendmode::Normal, \n</span><span>             </span><span style=\"color:#B45EA4\">typename</span><span> PorterDuff=porterduff::FastSourceOverOnOpaque,\n</span><span>             </span><span style=\"color:#B45EA4\">bool</span><span> antialias=</span><span style=\"color:#E7CE56\">false</span><span>, \n</span><span>             </span><span style=\"color:#B45EA4\">typename</span><span> number1=</span><span style=\"color:#B45EA4\">float</span><span>, </span><span style=\"color:#B45EA4\">typename</span><span> number2=</span><span style=\"color:#B45EA4\">float</span><span>, \n</span><span>             </span><span style=\"color:#B45EA4\">typename</span><span> Sampler&gt;\n</span><span>    </span><span style=\"color:#B45EA4\">void</span><span> drawTriangles(</span><span style=\"color:#B45EA4\">const</span><span> Sampler &amp; sampler,\n</span><span>                       </span><span style=\"color:#B45EA4\">const</span><span> matrix_3x3&lt;number1&gt; &amp;transform,\n</span><span>                       </span><span style=\"color:#B45EA4\">const</span><span> vec2&lt;number1&gt; * vertices= </span><span style=\"color:#E7CE56\">nullptr</span><span>,\n</span><span>                       </span><span style=\"color:#B45EA4\">const</span><span> vec2&lt;number2&gt; * uvs=</span><span style=\"color:#E7CE56\">nullptr</span><span>,\n</span><span>                       </span><span style=\"color:#B45EA4\">const</span><span> index * indices= </span><span style=\"color:#E7CE56\">nullptr</span><span>,\n</span><span>                       </span><span style=\"color:#B45EA4\">const</span><span> boundary_info * boundary_buffer= </span><span style=\"color:#E7CE56\">nullptr</span><span>,\n</span><span>                       index size=</span><span style=\"color:#E7CE56\">0</span><span>,\n</span><span>                       </span><span style=\"color:#B45EA4\">enum</span><span> indices type=indices::TRIANGLES,\n</span><span>                       </span><span style=\"color:#B45EA4\">opacity_t</span><span> opacity=</span><span style=\"color:#E7CE56\">255</span><span>,\n</span><span>                       </span><span style=\"color:#B45EA4\">const</span><span> number2 &amp;u0=number2(</span><span style=\"color:#E7CE56\">0</span><span>), </span><span style=\"color:#B45EA4\">const</span><span> number2 &amp;v0=number2(</span><span style=\"color:#E7CE56\">1</span><span>),\n</span><span>                       </span><span style=\"color:#B45EA4\">const</span><span> number2 &amp;u1=number2(</span><span style=\"color:#E7CE56\">1</span><span>), </span><span style=\"color:#B45EA4\">const</span><span> number2 &amp;v1=number2(</span><span style=\"color:#E7CE56\">0</span><span>));\n</span>\n<!-- -->\n</code></pre></pre>","scope":{}},"frontMatter":{},"document":{"name":"docs","groups":[{"title":"Getting Started","items":[{"title":"Setup","route":"getting-started/setup","path":"content/docs/microgl/setup.mdx"},{"title":"Features","route":"getting-started/features","path":"content/docs/microgl/features.mdx"}]},{"title":"Concepts","items":[{"title":"Numbers","route":"concepts/numbers","path":"content/docs/microgl/numbers.mdx"},{"title":"Math","route":"concepts/math","path":"content/docs/microgl/math.mdx"},{"title":"RGBA","route":"concepts/rgba","path":"content/docs/microgl/rgba.mdx"},{"title":"Pixel Coders","route":"concepts/pixel-coders","path":"content/docs/microgl/pixel-coders.mdx"},{"title":"Samplers","route":"concepts/samplers","path":"content/docs/microgl/samplers.mdx"},{"title":"Composition","route":"concepts/composition","path":"content/docs/microgl/composition.mdx"},{"title":"Bitmaps","route":"concepts/bitmaps","path":"content/docs/microgl/bitmaps.mdx"},{"title":"3D Shaders","route":"concepts/3d","path":"content/docs/microgl/3d.mdx"},{"title":"Canvas","route":"concepts/canvas","path":"content/docs/microgl/canvas.mdx"}]},{"title":"Drawing","items":[{"title":"Rectangles","route":"drawing/rectangles","path":"content/docs/microgl/rectangles.mdx"},{"title":"Rounded Shapes","route":"drawing/rounded","path":"content/docs/microgl/rounded.mdx"},{"title":"Quadrilaterals","route":"drawing/quadrilaterals","path":"content/docs/microgl/quadrilaterals.mdx"},{"title":"Triangle","route":"drawing/triangle","path":"content/docs/microgl/triangle.mdx"},{"title":"Triangle Batches","route":"drawing/triangle-batches","path":"content/docs/microgl/triangle-batches.mdx"},{"title":"Polygons","route":"drawing/polygons","path":"content/docs/microgl/polygons.mdx"},{"title":"Masks","route":"drawing/masks","path":"content/docs/microgl/masks.mdx"},{"title":"Path Fills","route":"drawing/path-fills","path":"content/docs/microgl/path-fills.mdx"},{"title":"Path Strokes","route":"drawing/path-stroke","path":"content/docs/microgl/path-stroke.mdx"},{"title":"Bezier Patches","route":"drawing/bezier-patches","path":"content/docs/microgl/patches.mdx"},{"title":"Lines","route":"drawing/lines","path":"content/docs/microgl/lines.mdx"},{"title":"Text","route":"drawing/text","path":"content/docs/microgl/text.mdx"},{"title":"Gradients","route":"drawing/gradients","path":"content/docs/microgl/gradients.mdx"},{"title":"More Samplers","route":"drawing/more-samplers","path":"content/docs/microgl/more-samplers.mdx"},{"title":"3D","route":"drawing/3d","path":"content/docs/microgl/draw-3d.mdx"}]}],"__map":{"getting-started/setup":"content/docs/microgl/setup.mdx","getting-started/features":"content/docs/microgl/features.mdx","concepts/numbers":"content/docs/microgl/numbers.mdx","concepts/math":"content/docs/microgl/math.mdx","concepts/rgba":"content/docs/microgl/rgba.mdx","concepts/pixel-coders":"content/docs/microgl/pixel-coders.mdx","concepts/samplers":"content/docs/microgl/samplers.mdx","concepts/composition":"content/docs/microgl/composition.mdx","concepts/bitmaps":"content/docs/microgl/bitmaps.mdx","concepts/3d":"content/docs/microgl/3d.mdx","concepts/canvas":"content/docs/microgl/canvas.mdx","drawing/rectangles":"content/docs/microgl/rectangles.mdx","drawing/rounded":"content/docs/microgl/rounded.mdx","drawing/quadrilaterals":"content/docs/microgl/quadrilaterals.mdx","drawing/triangle":"content/docs/microgl/triangle.mdx","drawing/triangle-batches":"content/docs/microgl/triangle-batches.mdx","drawing/polygons":"content/docs/microgl/polygons.mdx","drawing/masks":"content/docs/microgl/masks.mdx","drawing/path-fills":"content/docs/microgl/path-fills.mdx","drawing/path-stroke":"content/docs/microgl/path-stroke.mdx","drawing/bezier-patches":"content/docs/microgl/patches.mdx","drawing/lines":"content/docs/microgl/lines.mdx","drawing/text":"content/docs/microgl/text.mdx","drawing/gradients":"content/docs/microgl/gradients.mdx","drawing/more-samplers":"content/docs/microgl/more-samplers.mdx","drawing/3d":"content/docs/microgl/draw-3d.mdx"}}}},"__N_SSG":true}