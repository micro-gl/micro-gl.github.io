{"pageProps":{"data":{"slug":"concepts/canvas","content":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Introduction\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Canvas\"), \" is the main drawing concept in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"microgl\"), \". Canvas can be described as:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"An object with minimal state\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"An object that holds a \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"bitmap\"\n  }, \"bitmap\"), \" to draw on\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"a bunch of methods to draw shapes on a bitmap using \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"samplers\"\n  }, \"sampler\"), \" and \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"3d\"\n  }, \"3d-shaders\"))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Canvas\"), \" origin (0, 0) is at the top left like photoshop and spans to the bottom and right\")), mdx(\"p\", null, \"Canvas can be found at \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"<microgl/canvas.h>\")), \" and using it is a template, that can be instantieated\\nwith the following signature:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"/**\\n * @tparam bitmap_type  the bitmap type\\n * @tparam options      the options bitset\\n */\\ntemplate<typename bitmap_type, uint8_t options=CANVAS_OPT_default>\\nclass canvas {\\npublic:\\n    // the canvas type\\n    using canvas_t = ...\\n    // the underlying bitmap type\\n    using bitmap_t = ...\\n    // the pixel type of the bitmap\\n    using pixel = ...\\n    // the pixel coder type of the bitmap\\n    using pixel_coder = ...\\n\\n    struct window_t {\\n        rect canvas_rect;\\n        rect clip_rect;\\n        int index_correction=0;\\n    };\\n\\n    static constexpr bool options_compress_bits() { return options&CANVAS_OPT_raster_COMPRESS_BITS; }\\n    static constexpr bool options_big_integers() { return options&CANVAS_OPT_2d_raster_USE_BIG_INT; }\\n    static constexpr bool options_avoid_overflow() { return options&CANVAS_OPT_2d_raster_AVOID_RENDER_WITH_OVERFLOWS; }\\n    static constexpr bool options_use_division() { return options&CANVAS_OPT_2d_raster_USE_DIVISION; }\\n\\n    struct render_options_t {\\n        uint8_t _2d_raster_bits_sub_pixel= options_big_integers() ? 8 : 4;\\n        uint8_t _2d_raster_bits_uv= options_big_integers() ? 15 : 10;\\n        uint8_t _3d_raster_bits_sub_pixel= options_big_integers() ? 8 : 4;\\n        uint8_t _3d_raster_bits_w= options_big_integers() ? 15 : 12;\\n    };\\n\\n    /**\\n     * ctor of canvas that receives a bitmap reference\\n     *\\n     * @param $bmp a bitmap reference\\n     */\\n    explicit canvas(bitmap_type * $bmp)\\n    /**\\n     * ctor of canvas that allocate a bitmap internally\\n     * @param width     width of canvas\\n     * @param height    height of canvas\\n     */\\n    canvas(int width, int height)\\n\\n\\n    /**\\n     * where to position the bitmap relative to the canvas, this feature\\n     * can help with block rendering, where the bitmap is smaller than the canvas\\n     * diensions.\\n     *\\n     * @param left relative to x=0\\n     * @param top relative to y=0\\n     * @param $bmp (Optional) the bitmap reference\\n     */\\n    void updateCanvasWindow(int left, int top, bitmap_type * $bmp=nullptr)\\n\\n    /**\\n     * given that we know the canvas size and the clip rect, calculate\\n     * the sub rectangle (intersection), where drawing is visible\\n     *\\n     * @return a rectangle\\n     */\\n    rect calculateEffectiveDrawRect()\\n\\n\\n    /**\\n     * get the canvas rectangle, should be (0, 0, width, height), unless\\n     * the sub windowing feature was used.\\n     * @return a rectangle\\n     */\\n    const rect & canvasWindowRect() const\\n\\n    // get the rendering options\\n    render_options_t & renderingOptions()\\n\\n    // get canvas width\\n    int width() const;\\n    // get canvas height\\n    int height() const;\\n    // get size of pixel\\n    unsigned int sizeofPixel() const;\\n    // get the pixels array from the underlying bitmap\\n    pixel * pixels() const;\\n    // get a pixel by position\\n    pixel & getPixel(int x, int y) const ;\\n    pixel & getPixel(int index) const ;\\n    // decode pixel color by position\\n    void getPixelColor(int index, color_t & output) const;\\n    void getPixelColor(int x, int y, color_t & output) const;\\n\\n    // get the pixel coder reference of the underlying bitmap\\n    const pixel_coder & coder() const;\\n\\n    // get the underlying bitmap pointer\\n    bitmap_type * bitmapCanvas() const;\\n\\n    .\\n    .\\n    .\\n    .\\n\")), mdx(\"h1\", null, \"Usage\"), mdx(\"p\", null, \"Canvas can be simply used with the following c++ code\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"#include <microgl/canvas.h>\\n#include <microgl/pixel_coders/RGB888_PACKED_32.h>\\n\\nusing Canvas24= canvas<bitmap<coder::RGB888_PACKED_32>>;\\n\\nCanvas24 canvas_1(640, 480);\\n\\n// or with a given bitmap\\nCanvas24 canvas_2(new bitmap<coder::RGB888_PACKED_32>(img_2.data, img_2.width, img_2.height))\\n\")), mdx(\"h1\", null, \"Clipping\"), mdx(\"p\", null, \"Canvas implements a clipping feature where you can specify a rectangle, that will draw every\\npixel inside it and NOT draw outside of it, by default, the clip rectangle is the dimensions\\nof the canvas window, which by default is the size of the underlying bitmap.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public:\\n    /**\\n     * update the clipping rectangle of the canvas\\n     *\\n     * @param l left distance to x=0\\n     * @param t top distance to y=0\\n     * @param r right distance to x=0\\n     * @param b bottom distance to y=0\\n     */\\n    void updateClipRect(int l, int t, int r, int b)\\n    // get the clipping rectangle\\n    const rect & clipRect() const\\n\\n\")), mdx(\"h1\", null, \"Block Rendering and Windowing\"), mdx(\"p\", null, \"Canvas implements a block rendering feature, where you can move the canvas surface to\\nanother position. This can be leveraged to do the following:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Draw the canvas in blocks with a smaller bitmap and then copy it to external display\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This is ofcourse slower than drawing on entire canvas at once.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This is more memory friendly in memory constrained environments.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use it when the underlying bitmap is smaller than the clip rect\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public:\\n    /**\\n     * @param left relative to x=0\\n     * @param top relative to y=0\\n     * @param $bmp (Optional) the bitmap reference\\n     */\\n     void updateCanvasWindow(int left, int top, bitmap_type * $bmp=nullptr)\\n\")), mdx(\"p\", null, \"Here are 2 examples of renderings, that used 1/4 and 1/2 of the canvas size\"), mdx(\"div\", {\n    style: {\n      margin: \"auto\"\n    }\n  }, mdx(\"img\", {\n    src: \"/images/canvas_block_1.png\",\n    style: {\n      height: \"250px\",\n      display: \"inline-block\"\n    }\n  }), mdx(\"img\", {\n    src: \"/images/canvas_block_2.png\",\n    style: {\n      height: \"250px\",\n      display: \"inline-block\"\n    }\n  })), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Examples at \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"/examples/example_blocks_----.cpp\")))), mdx(\"h1\", null, \"Canvas Options\"), mdx(\"p\", null, \"When the Canvas template is instantieated, it can be with a bitfield parameter to control some\\nthings. Options can be concatenated. Here are the current options:\"), mdx(\"h3\", null, \"CANVAS_OPT_2d_raster_USE_BIG_INT\"), mdx(\"p\", null, \"Use big integers for 2d rasterizer, this implies a 64 bits place holders\\nfor all or most calculations inside the rasterizer. bigger integers imply\\noverflow is harder to come by\"), mdx(\"h3\", null, \"CANVAS_OPT_2d_raster_USE_DIVISION\"), mdx(\"p\", null, \"Inside the 2d rasterizer, use division for uv-mapping, this reduces\\nthe number of bits used BUT is slower. Generally this HAS to be used\\non a forced 32 bit rasterizer, in case you want a pure 32 bit integers\\nonly during rasterization. Do not use it when in BIG INT mode.\"), mdx(\"h3\", null, \"CANVAS_OPT_2d_raster_AVOID_RENDER_WITH_OVERFLOWS\"), mdx(\"p\", null, \"The 2d and 3d rasterizer can detect overflow of uv mapping, the detection\\nfeature is great for debugging the rasterizer. this flag enables detection\\nand if so, exits the rendering. This is helpful for when using a 32 bit mode,\\nwhere overflows are likely to happen\"), mdx(\"h3\", null, \"CANVAS_OPT_2d_raster_FORCE_32_BIT\"), mdx(\"p\", null, \"Use a true 32 bit mode in the 2d and 3d rasterizer, this means regular 32 bit integers\\nand also the usage of division in order to reduce overflow and also detecting\\nand exiting on overflows as they are likely to happen in 32 bit mode, if so,\\nplease adjust some of the render options bits in the canvas and make sure you\\nrender small geometries at a time  \"), mdx(\"p\", null, \"CANVAS_OPT_2d_raster_USE_DIVISION | CANVAS_OPT_2d_raster_AVOID_RENDER_WITH_OVERFLOWS | CANVAS_OPT_raster_COMPRESS_BITS\"), mdx(\"h3\", null, \"CANVAS_OPT_2d_raster_FORCE_64_BIT (default)\"), mdx(\"p\", null, \"Force 64 bits\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"CANVAS_OPT_2d_raster_USE_BIG_INT | CANVAS_OPT_2d_raster_AVOID_RENDER_WITH_OVERFLOWS\"), mdx(\"h3\", null, \"Usage\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"#include <microgl/canvas.h>\\n#include <microgl/pixel_coders/RGB888_PACKED_32.h>\\n\\n\\nusing Bitmap= bitmap<coder::RGB888_PACKED_32>;\\nusing Canvas24= canvas<Bitmap, CANVAS_OPT_2d_raster_FORCE_32_BIT>;\\n\\nCanvas24 canvas_1(640, 480);\\n\")), mdx(\"h1\", null, \"Rendering Options\"), mdx(\"p\", null, \"At any moment you can fine tune the precision (count of bits), that is spent on\\nthe 2d and 3d rasterizer via aquiring the rendering options\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"public:\\n  render_options_t & renderingOptions();\\n\")), mdx(\"p\", null, \"Which return the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"render_options_t\"), \" struct\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"struct render_options_t {\\n    uint8_t _2d_raster_bits_sub_pixel= options_big_integers() ? 8 : 4;\\n    uint8_t _2d_raster_bits_uv= options_big_integers() ? 15 : 10;\\n    uint8_t _3d_raster_bits_sub_pixel= options_big_integers() ? 8 : 4;\\n    uint8_t _3d_raster_bits_w= options_big_integers() ? 15 : 12;\\n};\\n\")), mdx(\"h3\", null, mdx(\"em\", {\n    parentName: \"h3\"\n  }, \"_2d_raster_bits_sub_pixel\")), mdx(\"p\", null, \"The number of bits spent on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sub-pixel\"), \" precision. The more you spend, the smoother animation will\\nbe precieved.\"), mdx(\"h3\", null, mdx(\"em\", {\n    parentName: \"h3\"\n  }, \"_2d_raster_bits_uv\")), mdx(\"p\", null, \"The number of bits spent on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uv\"), \" precision. The more you spend, the better the sampling will look.\"), mdx(\"h3\", null, mdx(\"em\", {\n    parentName: \"h3\"\n  }, \"_3d_raster_bits_sub_pixel\")), mdx(\"p\", null, \"The number of bits spent on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sub-pixel\"), \" precision. The more you spend, the smoother animation will\\nbe precieved.\"), mdx(\"h3\", null, mdx(\"em\", {\n    parentName: \"h3\"\n  }, \"_3d_raster_bits_w\")), mdx(\"p\", null, \"The number of bits spent on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"w\"), \" precision. The more you spend, then better interpolations (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"barycentric\"), \" coords)\\nwill be produced.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The trick is to fine tune these values based on 32/64 bit mode and the size of the shapes bounding boxes.\")), mdx(\"h1\", null, \"Supported Shapes\"), mdx(\"p\", null, \"Canvas can draw the following shapes with a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"samplers\"\n  }, \"sampler\"), \" and a matrix transform.\"), mdx(\"h2\", null, \"Rectangles\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Example at \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"/examples/example_draw_rect_transform.cpp\")))), mdx(\"img\", {\n    src: \"/images/canvas_rect.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h2\", null, \"Rounded Rectangles\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Example at \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"/examples/example_draw_rounded_rectangle.cpp\")))), mdx(\"img\", {\n    src: \"/images/canvas_rounded_rect.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h2\", null, \"Triangle\"), mdx(\"blockquote\", null, mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Example at \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"/examples/example_draw_triangle.cpp\")), \" \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Example at \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"/examples/example_draw_triangles_matrix_transforms.cpp\"))))), mdx(\"p\", null, \"You can also draw triangles in batches\"), mdx(\"img\", {\n    src: \"/images/canvas_triangle.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h2\", null, \"Polygon\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Examples at \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"/examples/example_draw_polygon.cpp\")), \" \")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"microgl\"), \" can draw convex, concave, simple, monotone, self intersecting and complex polygon.\\ni.e polygons of all types.\"), mdx(\"img\", {\n    src: \"/images/canvas_polygon.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h2\", null, \"Circles\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Examples at \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"/examples/example_draw_circles.cpp\")), \" \")), mdx(\"img\", {\n    src: \"/images/canvas_circle.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h2\", null, \"Quadrilaterals (4 points with perspective)\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Examples at \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"/examples/example_draw_quadrilaterals.cpp\")), \" \")), mdx(\"img\", {\n    src: \"/images/canvas_quadri.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h2\", null, \"Masks\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Examples at \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"/examples/example_draw_masks.cpp\")), \" \")), mdx(\"img\", {\n    src: \"/images/canvas_mask.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h2\", null, \"Path fills\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Examples at \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"/examples/example_draw_path.cpp\")), \" \")), mdx(\"p\", null, \"Paths are vector graphics shapes defined by lines, bezier paths, elliptic arcs and more.\\nWith them you can define multiple shapes, that when combined might for a complex polygon.\\nafter tessalation, the paths are filled using the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"one-zero\")), \" or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"even-odd\")), \" criterion\"), mdx(\"img\", {\n    src: \"/images/canvas_path.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h2\", null, \"Path Strokes\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Examples at \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"/examples/example_draw_path_stroke.cpp\")), \" \")), mdx(\"p\", null, \"Paths strokes are vector graphics paths defined by lines, bezier paths, arcs and more.\\nwhen tessalated, you can define things like:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"stroke dash pattern and offset (useful for animation)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"stroke cap of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"butt\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"round\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"square\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"stroke line join of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"none\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"miter\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"miter_clip\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"round\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"bevel\"))), mdx(\"div\", {\n    style: {\n      margin: \"auto\"\n    }\n  }, mdx(\"img\", {\n    src: \"/images/canvas_stroke.png\",\n    style: {\n      height: \"250px\",\n      display: \"inline-block\"\n    }\n  }), mdx(\"img\", {\n    src: \"/images/canvas_stroke_dash.png\",\n    style: {\n      height: \"250px\",\n      display: \"inline-block\"\n    }\n  })), mdx(\"h2\", null, \"Bezier Patches\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Examples at \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"/examples/example_draw_bezier_patch.cpp\")), \" \")), mdx(\"p\", null, \"Bezier patches of 2nd and 3rd degree, Quadratic and Cubic orders are supported as well\"), mdx(\"img\", {\n    src: \"/images/canvas_bezier_patch.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }), mdx(\"h2\", null, \"Lines (Wu lines)\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Examples at \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"/examples/example_3d_simple_pipeline.cpp\")), \" \")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Examples at \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"/examples/example_geometry_bezier_curve_divider.cpp\")), \" \")), mdx(\"p\", null, \"Wu lines algorithm is supported, it is a fast DDA algorithm, supports anti-aliasing\\nbut is not very accurate.\"), mdx(\"img\", {\n    src: \"/images/canvas_wu_lines.png\",\n    style: {\n      height: \"250px\",\n      margin: \"auto\"\n    }\n  }));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<h1 class=\"css-0\">Introduction</h1><p class=\"css-0\"><style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">Canvas</strong> is the main drawing concept in <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">microgl</div>. Canvas can be described as:</p><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">An object with minimal state</li><li class=\"css-b0qdn7\">An object that holds a <style data-emotion=\"css 1kc89wa\">.css-1kc89wa{color:purple.500;}</style><a class=\"chakra-link css-1kc89wa\" href=\"bitmap\">bitmap</a> to draw on</li><li class=\"css-b0qdn7\">a bunch of methods to draw shapes on a bitmap using <a class=\"chakra-link css-1kc89wa\" href=\"samplers\">sampler</a> and <a class=\"chakra-link css-1kc89wa\" href=\"3d\">3d-shaders</a></li></ul><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\"><style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\">Canvas</strong> origin (0, 0) is at the top left like photoshop and spans to the bottom and right</p></blockquote><p class=\"css-0\">Canvas can be found at <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">&lt;microgl/canvas.h&gt;</div></strong> and using it is a template, that can be instantieated\nwith the following signature:</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\"> * @tparam bitmap_type  the bitmap type\n</span><span class=\"hljs-function\"> * @tparam options      the options bitset\n</span><span style=\"color:#B6B18B\"> */</span><span>\n</span><span></span><span style=\"color:#B45EA4\">template</span><span>&lt;</span><span style=\"color:#B45EA4\">typename</span><span> bitmap_type, </span><span style=\"color:#B45EA4\">uint8_t</span><span> options=CANVAS_OPT_default&gt;\n</span>class canvas {\n<span></span><span style=\"color:#B45EA4\">public</span><span>:\n</span><span>    </span><span style=\"color:#B6B18B\">// the canvas type</span><span>\n</span><span>    </span><span style=\"color:#B45EA4\">using</span><span> </span><span style=\"color:#B45EA4\">canvas_t</span><span> = ...\n</span><span>    </span><span style=\"color:#B6B18B\">// the underlying bitmap type</span><span>\n</span><span>    </span><span style=\"color:#B45EA4\">using</span><span> </span><span style=\"color:#B45EA4\">bitmap_t</span><span> = ...\n</span><span>    </span><span style=\"color:#B6B18B\">// the pixel type of the bitmap</span><span>\n</span><span>    </span><span style=\"color:#B45EA4\">using</span><span> pixel = ...\n</span><span>    </span><span style=\"color:#B6B18B\">// the pixel coder type of the bitmap</span><span>\n</span><span>    </span><span style=\"color:#B45EA4\">using</span><span> pixel_coder = ...\n</span>\n<span>    struct </span><span style=\"color:#B45EA4\">window_t</span><span> {\n</span>        rect canvas_rect;\n<!-- -->        rect clip_rect;\n<span>        </span><span style=\"color:#B45EA4\">int</span><span> index_correction=</span><span style=\"color:#E7CE56\">0</span><span>;\n</span>    };\n<!-- -->\n<span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">static</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">constexpr</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">bool</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">options_compress_bits</span><span class=\"hljs-function\" style=\"color:#E7CE56\">()</span><span class=\"hljs-function\"> </span><span>{ </span><span style=\"color:#B45EA4\">return</span><span> options&amp;CANVAS_OPT_raster_COMPRESS_BITS; }\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">static</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">constexpr</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">bool</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">options_big_integers</span><span class=\"hljs-function\" style=\"color:#E7CE56\">()</span><span class=\"hljs-function\"> </span><span>{ </span><span style=\"color:#B45EA4\">return</span><span> options&amp;CANVAS_OPT_2d_raster_USE_BIG_INT; }\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">static</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">constexpr</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">bool</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">options_avoid_overflow</span><span class=\"hljs-function\" style=\"color:#E7CE56\">()</span><span class=\"hljs-function\"> </span><span>{ </span><span style=\"color:#B45EA4\">return</span><span> options&amp;CANVAS_OPT_2d_raster_AVOID_RENDER_WITH_OVERFLOWS; }\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">static</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">constexpr</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">bool</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">options_use_division</span><span class=\"hljs-function\" style=\"color:#E7CE56\">()</span><span class=\"hljs-function\"> </span><span>{ </span><span style=\"color:#B45EA4\">return</span><span> options&amp;CANVAS_OPT_2d_raster_USE_DIVISION; }\n</span>\n<span>    </span><span class=\"hljs-class\" style=\"color:#B45EA4\">struct</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">render_options_t</span><span class=\"hljs-class\"> {</span><span>\n</span><span>        </span><span style=\"color:#B45EA4\">uint8_t</span><span> _2d_raster_bits_sub_pixel= options_big_integers() ? </span><span style=\"color:#E7CE56\">8</span><span> : </span><span style=\"color:#E7CE56\">4</span><span>;\n</span><span>        </span><span style=\"color:#B45EA4\">uint8_t</span><span> _2d_raster_bits_uv= options_big_integers() ? </span><span style=\"color:#E7CE56\">15</span><span> : </span><span style=\"color:#E7CE56\">10</span><span>;\n</span><span>        </span><span style=\"color:#B45EA4\">uint8_t</span><span> _3d_raster_bits_sub_pixel= options_big_integers() ? </span><span style=\"color:#E7CE56\">8</span><span> : </span><span style=\"color:#E7CE56\">4</span><span>;\n</span><span>        </span><span style=\"color:#B45EA4\">uint8_t</span><span> _3d_raster_bits_w= options_big_integers() ? </span><span style=\"color:#E7CE56\">15</span><span> : </span><span style=\"color:#E7CE56\">12</span><span>;\n</span>    };\n<!-- -->\n<span>    </span><span style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\">     * ctor of canvas that receives a bitmap reference\n</span><span class=\"hljs-function\">     *\n</span><span class=\"hljs-function\">     * @param $bmp a bitmap reference\n</span><span style=\"color:#B6B18B\">     */</span><span>\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">explicit</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">canvas</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(bitmap_type * $bmp)</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\">     * ctor of canvas that allocate a bitmap internally\n</span><span class=\"hljs-function\">     * @param width     width of canvas\n</span><span class=\"hljs-function\">     * @param height    height of canvas\n</span><span class=\"hljs-function\" style=\"color:#B6B18B\">     */</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#78BB65\">canvas</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> width, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> height)</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\">     * where to position the bitmap relative to the canvas, this feature\n</span><span class=\"hljs-function\">     * can help with block rendering, where the bitmap is smaller than the canvas\n</span><span class=\"hljs-function\">     * diensions.\n</span><span class=\"hljs-function\">     *\n</span><span class=\"hljs-function\">     * @param left relative to x=0\n</span><span class=\"hljs-function\">     * @param top relative to y=0\n</span><span class=\"hljs-function\">     * @param $bmp (Optional) the bitmap reference\n</span><span class=\"hljs-function\" style=\"color:#B6B18B\">     */</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">updateCanvasWindow</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> left, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> top, bitmap_type * $bmp=</span><span class=\"hljs-function\" style=\"color:#E7CE56\">nullptr</span><span class=\"hljs-function\" style=\"color:#E7CE56\">)</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\">     * given that we know the canvas size and the clip rect, calculate\n</span><span class=\"hljs-function\">     * the sub rectangle (intersection), where drawing is visible\n</span><span class=\"hljs-function\">     *\n</span><span class=\"hljs-function\">     * @return a rectangle\n</span><span class=\"hljs-function\" style=\"color:#B6B18B\">     */</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    rect </span><span class=\"hljs-function\" style=\"color:#78BB65\">calculateEffectiveDrawRect</span><span class=\"hljs-function\" style=\"color:#E7CE56\">()</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\">     * get the canvas rectangle, should be (0, 0, width, height), unless\n</span><span class=\"hljs-function\">     * the sub windowing feature was used.\n</span><span class=\"hljs-function\">     * @return a rectangle\n</span><span class=\"hljs-function\" style=\"color:#B6B18B\">     */</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\"> rect &amp; </span><span class=\"hljs-function\" style=\"color:#78BB65\">canvasWindowRect</span><span class=\"hljs-function\" style=\"color:#E7CE56\">()</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B6B18B\">// get the rendering options</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">render_options_t</span><span class=\"hljs-function\"> &amp; </span><span class=\"hljs-function\" style=\"color:#78BB65\">renderingOptions</span><span class=\"hljs-function\" style=\"color:#E7CE56\">()</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B6B18B\">// get canvas width</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">width</span><span class=\"hljs-function\" style=\"color:#E7CE56\">()</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span>;\n</span><span>    </span><span style=\"color:#B6B18B\">// get canvas height</span><span>\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">height</span><span class=\"hljs-function\" style=\"color:#E7CE56\">()</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span>;\n</span><span>    </span><span style=\"color:#B6B18B\">// get size of pixel</span><span>\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">unsigned</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">sizeofPixel</span><span class=\"hljs-function\" style=\"color:#E7CE56\">()</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span>;\n</span><span>    </span><span style=\"color:#B6B18B\">// get the pixels array from the underlying bitmap</span><span>\n</span><span>    </span><span class=\"hljs-function\">pixel * </span><span class=\"hljs-function\" style=\"color:#78BB65\">pixels</span><span class=\"hljs-function\" style=\"color:#E7CE56\">()</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span>;\n</span><span>    </span><span style=\"color:#B6B18B\">// get a pixel by position</span><span>\n</span><span>    </span><span class=\"hljs-function\">pixel &amp; </span><span class=\"hljs-function\" style=\"color:#78BB65\">getPixel</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> x, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> y)</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\"> </span><span>;\n</span><span>    </span><span class=\"hljs-function\">pixel &amp; </span><span class=\"hljs-function\" style=\"color:#78BB65\">getPixel</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> index)</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\"> </span><span>;\n</span><span>    </span><span style=\"color:#B6B18B\">// decode pixel color by position</span><span>\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">getPixelColor</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> index, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp; output)</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span>;\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">getPixelColor</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> x, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> y, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">color_t</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> &amp; output)</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span>;\n</span>\n<span>    </span><span style=\"color:#B6B18B\">// get the pixel coder reference of the underlying bitmap</span><span>\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\"> pixel_coder &amp; </span><span class=\"hljs-function\" style=\"color:#78BB65\">coder</span><span class=\"hljs-function\" style=\"color:#E7CE56\">()</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span>;\n</span>\n<span>    </span><span style=\"color:#B6B18B\">// get the underlying bitmap pointer</span><span>\n</span><span>    </span><span class=\"hljs-function\">bitmap_type * </span><span class=\"hljs-function\" style=\"color:#78BB65\">bitmapCanvas</span><span class=\"hljs-function\" style=\"color:#E7CE56\">()</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span>;\n</span>\n<!-- -->    .\n<!-- -->    .\n<!-- -->    .\n<!-- -->    .\n<!-- -->\n</code></pre></pre><h1 class=\"css-0\">Usage</h1><p class=\"css-0\">Canvas can be simply used with the following c++ code</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#E7CE56\">#</span><span class=\"hljs-meta-keyword\" style=\"color:#E7CE56\">include</span><span style=\"color:#E7CE56\"> </span><span class=\"hljs-meta-string\" style=\"color:#E7CE56\">&lt;microgl/canvas.h&gt;</span><span>\n</span><span></span><span style=\"color:#E7CE56\">#</span><span class=\"hljs-meta-keyword\" style=\"color:#E7CE56\">include</span><span style=\"color:#E7CE56\"> </span><span class=\"hljs-meta-string\" style=\"color:#E7CE56\">&lt;microgl/pixel_coders/RGB888_PACKED_32.h&gt;</span><span>\n</span>\n<span></span><span style=\"color:#B45EA4\">using</span><span> Canvas24= canvas&lt;bitmap&lt;coder::RGB888_PACKED_32&gt;&gt;;\n</span>\n<span></span><span class=\"hljs-function\">Canvas24 </span><span class=\"hljs-function\" style=\"color:#78BB65\">canvas_1</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#E7CE56\">640</span><span class=\"hljs-function\" style=\"color:#E7CE56\">, </span><span class=\"hljs-function\" style=\"color:#E7CE56\">480</span><span class=\"hljs-function\" style=\"color:#E7CE56\">)</span><span>;\n</span>\n<span></span><span style=\"color:#B6B18B\">// or with a given bitmap</span><span>\n</span><span></span><span class=\"hljs-function\">Canvas24 </span><span class=\"hljs-function\" style=\"color:#78BB65\">canvas_2</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">new</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> bitmap&lt;coder::RGB888_PACKED_32&gt;(img_2.data, img_2.width, img_2.height))</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span></code></pre></pre><h1 class=\"css-0\">Clipping</h1><p class=\"css-0\">Canvas implements a clipping feature where you can specify a rectangle, that will draw every\npixel inside it and NOT draw outside of it, by default, the clip rectangle is the dimensions\nof the canvas window, which by default is the size of the underlying bitmap.</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B45EA4\">public</span><span>:\n</span><span>    </span><span style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\">     * update the clipping rectangle of the canvas\n</span><span class=\"hljs-function\">     *\n</span><span class=\"hljs-function\">     * @param l left distance to x=0\n</span><span class=\"hljs-function\">     * @param t top distance to y=0\n</span><span class=\"hljs-function\">     * @param r right distance to x=0\n</span><span class=\"hljs-function\">     * @param b bottom distance to y=0\n</span><span style=\"color:#B6B18B\">     */</span><span>\n</span><span>    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">updateClipRect</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> l, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> t, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> r, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> b)</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B6B18B\">// get the clipping rectangle</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">    </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\"> rect &amp; </span><span class=\"hljs-function\" style=\"color:#78BB65\">clipRect</span><span class=\"hljs-function\" style=\"color:#E7CE56\">()</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#B45EA4\">const</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span></code></pre></pre><h1 class=\"css-0\">Block Rendering and Windowing</h1><p class=\"css-0\">Canvas implements a block rendering feature, where you can move the canvas surface to\nanother position. This can be leveraged to do the following:</p><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">Draw the canvas in blocks with a smaller bitmap and then copy it to external display</li><li class=\"css-b0qdn7\">This is ofcourse slower than drawing on entire canvas at once.</li><li class=\"css-b0qdn7\">This is more memory friendly in memory constrained environments.</li><li class=\"css-b0qdn7\">Use it when the underlying bitmap is smaller than the clip rect</li></ul><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B45EA4\">public</span><span>:\n</span><span>    </span><span style=\"color:#B6B18B\">/**\n</span><span class=\"hljs-function\">     * @param left relative to x=0\n</span><span class=\"hljs-function\">     * @param top relative to y=0\n</span><span class=\"hljs-function\">     * @param $bmp (Optional) the bitmap reference\n</span><span style=\"color:#B6B18B\">     */</span><span>\n</span><span>     </span><span class=\"hljs-function\" style=\"color:#B45EA4\">void</span><span class=\"hljs-function\"> </span><span class=\"hljs-function\" style=\"color:#78BB65\">updateCanvasWindow</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> left, </span><span class=\"hljs-function\" style=\"color:#B45EA4\">int</span><span class=\"hljs-function\" style=\"color:#E7CE56\"> top, bitmap_type * $bmp=</span><span class=\"hljs-function\" style=\"color:#E7CE56\">nullptr</span><span class=\"hljs-function\" style=\"color:#E7CE56\">)</span><span class=\"hljs-function\">\n</span><span class=\"hljs-function\">\n</span></code></pre></pre><p class=\"css-0\">Here are 2 examples of renderings, that used 1/4 and 1/2 of the canvas size</p><div style=\"margin:auto\"><img src=\"/images/canvas_block_1.png\" style=\"height:250px;display:inline-block\"/><img src=\"/images/canvas_block_2.png\" style=\"height:250px;display:inline-block\"/></div><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">Examples at <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">/examples/example_blocks_----.cpp</div></strong></p></blockquote><h1 class=\"css-0\">Canvas Options</h1><p class=\"css-0\">When the Canvas template is instantieated, it can be with a bitfield parameter to control some\nthings. Options can be concatenated. Here are the current options:</p><h3 class=\"css-0\">CANVAS_OPT_2d_raster_USE_BIG_INT</h3><p class=\"css-0\">Use big integers for 2d rasterizer, this implies a 64 bits place holders\nfor all or most calculations inside the rasterizer. bigger integers imply\noverflow is harder to come by</p><h3 class=\"css-0\">CANVAS_OPT_2d_raster_USE_DIVISION</h3><p class=\"css-0\">Inside the 2d rasterizer, use division for uv-mapping, this reduces\nthe number of bits used BUT is slower. Generally this HAS to be used\non a forced 32 bit rasterizer, in case you want a pure 32 bit integers\nonly during rasterization. Do not use it when in BIG INT mode.</p><h3 class=\"css-0\">CANVAS_OPT_2d_raster_AVOID_RENDER_WITH_OVERFLOWS</h3><p class=\"css-0\">The 2d and 3d rasterizer can detect overflow of uv mapping, the detection\nfeature is great for debugging the rasterizer. this flag enables detection\nand if so, exits the rendering. This is helpful for when using a 32 bit mode,\nwhere overflows are likely to happen</p><h3 class=\"css-0\">CANVAS_OPT_2d_raster_FORCE_32_BIT</h3><p class=\"css-0\">Use a true 32 bit mode in the 2d and 3d rasterizer, this means regular 32 bit integers\nand also the usage of division in order to reduce overflow and also detecting\nand exiting on overflows as they are likely to happen in 32 bit mode, if so,\nplease adjust some of the render options bits in the canvas and make sure you\nrender small geometries at a time  </p><p class=\"css-0\">CANVAS_OPT_2d_raster_USE_DIVISION | CANVAS_OPT_2d_raster_AVOID_RENDER_WITH_OVERFLOWS | CANVAS_OPT_raster_COMPRESS_BITS</p><h3 class=\"css-0\">CANVAS_OPT_2d_raster_FORCE_64_BIT (default)</h3><p class=\"css-0\">Force 64 bits<div class=\"css-0\"></div>\n<!-- -->CANVAS_OPT_2d_raster_USE_BIG_INT | CANVAS_OPT_2d_raster_AVOID_RENDER_WITH_OVERFLOWS</p><h3 class=\"css-0\">Usage</h3><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#E7CE56\">#</span><span class=\"hljs-meta-keyword\" style=\"color:#E7CE56\">include</span><span style=\"color:#E7CE56\"> </span><span class=\"hljs-meta-string\" style=\"color:#E7CE56\">&lt;microgl/canvas.h&gt;</span><span>\n</span><span></span><span style=\"color:#E7CE56\">#</span><span class=\"hljs-meta-keyword\" style=\"color:#E7CE56\">include</span><span style=\"color:#E7CE56\"> </span><span class=\"hljs-meta-string\" style=\"color:#E7CE56\">&lt;microgl/pixel_coders/RGB888_PACKED_32.h&gt;</span><span>\n</span>\n<!-- -->\n<span></span><span style=\"color:#B45EA4\">using</span><span> Bitmap= bitmap&lt;coder::RGB888_PACKED_32&gt;;\n</span><span></span><span style=\"color:#B45EA4\">using</span><span> Canvas24= canvas&lt;Bitmap, CANVAS_OPT_2d_raster_FORCE_32_BIT&gt;;\n</span>\n<span></span><span class=\"hljs-function\">Canvas24 </span><span class=\"hljs-function\" style=\"color:#78BB65\">canvas_1</span><span class=\"hljs-function\" style=\"color:#E7CE56\">(</span><span class=\"hljs-function\" style=\"color:#E7CE56\">640</span><span class=\"hljs-function\" style=\"color:#E7CE56\">, </span><span class=\"hljs-function\" style=\"color:#E7CE56\">480</span><span class=\"hljs-function\" style=\"color:#E7CE56\">)</span><span>;\n</span>\n</code></pre></pre><h1 class=\"css-0\">Rendering Options</h1><p class=\"css-0\">At any moment you can fine tune the precision (count of bits), that is spent on\nthe 2d and 3d rasterizer via aquiring the rendering options</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span style=\"color:#B45EA4\">public</span><span>:\n</span><span>  </span><span class=\"hljs-function\" style=\"color:#B45EA4\">render_options_t</span><span class=\"hljs-function\"> &amp; </span><span class=\"hljs-function\" style=\"color:#78BB65\">renderingOptions</span><span class=\"hljs-function\" style=\"color:#E7CE56\">()</span><span>;\n</span>\n</code></pre></pre><p class=\"css-0\">Which return the <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">render_options_t</div> struct</p><pre><pre style=\"display:block;overflow-x:auto;background:#1C1D21;color:#c0c5ce;padding:0.5em;border-radius:10px;padding-left:20px;padding-top:20px\"><code class=\"language-cpp\" style=\"white-space:pre\"><span class=\"hljs-class\" style=\"color:#B45EA4\">struct</span><span class=\"hljs-class\"> </span><span class=\"hljs-class\" style=\"color:#78BB65\">render_options_t</span><span class=\"hljs-class\"> {</span><span>\n</span><span>    </span><span style=\"color:#B45EA4\">uint8_t</span><span> _2d_raster_bits_sub_pixel= options_big_integers() ? </span><span style=\"color:#E7CE56\">8</span><span> : </span><span style=\"color:#E7CE56\">4</span><span>;\n</span><span>    </span><span style=\"color:#B45EA4\">uint8_t</span><span> _2d_raster_bits_uv= options_big_integers() ? </span><span style=\"color:#E7CE56\">15</span><span> : </span><span style=\"color:#E7CE56\">10</span><span>;\n</span><span>    </span><span style=\"color:#B45EA4\">uint8_t</span><span> _3d_raster_bits_sub_pixel= options_big_integers() ? </span><span style=\"color:#E7CE56\">8</span><span> : </span><span style=\"color:#E7CE56\">4</span><span>;\n</span><span>    </span><span style=\"color:#B45EA4\">uint8_t</span><span> _3d_raster_bits_w= options_big_integers() ? </span><span style=\"color:#E7CE56\">15</span><span> : </span><span style=\"color:#E7CE56\">12</span><span>;\n</span>};\n<!-- -->\n</code></pre></pre><h3 class=\"css-0\"><em>_2d_raster_bits_sub_pixel</em></h3><p class=\"css-0\">The number of bits spent on <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">sub-pixel</div> precision. The more you spend, the smoother animation will\nbe precieved.</p><h3 class=\"css-0\"><em>_2d_raster_bits_uv</em></h3><p class=\"css-0\">The number of bits spent on <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">uv</div> precision. The more you spend, the better the sampling will look.</p><h3 class=\"css-0\"><em>_3d_raster_bits_sub_pixel</em></h3><p class=\"css-0\">The number of bits spent on <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">sub-pixel</div> precision. The more you spend, the smoother animation will\nbe precieved.</p><h3 class=\"css-0\"><em>_3d_raster_bits_w</em></h3><p class=\"css-0\">The number of bits spent on <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">w</div> precision. The more you spend, then better interpolations (<div class=\"css-qskmz3\">barycentric</div> coords)\nwill be produced.</p><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">The trick is to fine tune these values based on 32/64 bit mode and the size of the shapes bounding boxes.</p></blockquote><h1 class=\"css-0\">Supported Shapes</h1><p class=\"css-0\">Canvas can draw the following shapes with a <style data-emotion=\"css 1kc89wa\">.css-1kc89wa{color:purple.500;}</style><a class=\"chakra-link css-1kc89wa\" href=\"samplers\">sampler</a> and a matrix transform.</p><h2 class=\"css-0\">Rectangles</h2><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">Example at <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">/examples/example_draw_rect_transform.cpp</div></strong></p></blockquote><img src=\"/images/canvas_rect.png\" style=\"height:250px;margin:auto\"/><h2 class=\"css-0\">Rounded Rectangles</h2><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">Example at <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">/examples/example_draw_rounded_rectangle.cpp</div></strong></p></blockquote><img src=\"/images/canvas_rounded_rect.png\" style=\"height:250px;margin:auto\"/><h2 class=\"css-0\">Triangle</h2><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">Example at <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">/examples/example_draw_triangle.cpp</div></strong> </li><li class=\"css-b0qdn7\">Example at <strong class=\"css-10ircq3\"><div class=\"css-qskmz3\">/examples/example_draw_triangles_matrix_transforms.cpp</div></strong></li></ul></blockquote><p class=\"css-0\">You can also draw triangles in batches</p><img src=\"/images/canvas_triangle.png\" style=\"height:250px;margin:auto\"/><h2 class=\"css-0\">Polygon</h2><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">Examples at <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">/examples/example_draw_polygon.cpp</div></strong> </p></blockquote><p class=\"css-0\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">microgl</div> can draw convex, concave, simple, monotone, self intersecting and complex polygon.\ni.e polygons of all types.</p><img src=\"/images/canvas_polygon.png\" style=\"height:250px;margin:auto\"/><h2 class=\"css-0\">Circles</h2><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">Examples at <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">/examples/example_draw_circles.cpp</div></strong> </p></blockquote><img src=\"/images/canvas_circle.png\" style=\"height:250px;margin:auto\"/><h2 class=\"css-0\">Quadrilaterals (4 points with perspective)</h2><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">Examples at <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">/examples/example_draw_quadrilaterals.cpp</div></strong> </p></blockquote><img src=\"/images/canvas_quadri.png\" style=\"height:250px;margin:auto\"/><h2 class=\"css-0\">Masks</h2><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">Examples at <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">/examples/example_draw_masks.cpp</div></strong> </p></blockquote><img src=\"/images/canvas_mask.png\" style=\"height:250px;margin:auto\"/><h2 class=\"css-0\">Path fills</h2><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">Examples at <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">/examples/example_draw_path.cpp</div></strong> </p></blockquote><p class=\"css-0\">Paths are vector graphics shapes defined by lines, bezier paths, elliptic arcs and more.\nWith them you can define multiple shapes, that when combined might for a complex polygon.\nafter tessalation, the paths are filled using the <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">one-zero</div></strong> or <strong class=\"css-10ircq3\"><div class=\"css-qskmz3\">even-odd</div></strong> criterion</p><img src=\"/images/canvas_path.png\" style=\"height:250px;margin:auto\"/><h2 class=\"css-0\">Path Strokes</h2><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">Examples at <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">/examples/example_draw_path_stroke.cpp</div></strong> </p></blockquote><p class=\"css-0\">Paths strokes are vector graphics paths defined by lines, bezier paths, arcs and more.\nwhen tessalated, you can define things like:</p><ul class=\"css-0\"><style data-emotion=\"css b0qdn7\">.css-b0qdn7{padding-bottom:4px;}</style><li class=\"css-b0qdn7\">stroke dash pattern and offset (useful for animation)</li><li class=\"css-b0qdn7\">stroke cap of <style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">butt</div>, <div class=\"css-qskmz3\">round</div>, <div class=\"css-qskmz3\">square</div></li><li class=\"css-b0qdn7\">stroke line join of <div class=\"css-qskmz3\">none</div>, <div class=\"css-qskmz3\">miter</div>, <div class=\"css-qskmz3\">miter_clip</div>, <div class=\"css-qskmz3\">round</div>, <div class=\"css-qskmz3\">bevel</div></li></ul><div style=\"margin:auto\"><img src=\"/images/canvas_stroke.png\" style=\"height:250px;display:inline-block\"/><img src=\"/images/canvas_stroke_dash.png\" style=\"height:250px;display:inline-block\"/></div><h2 class=\"css-0\">Bezier Patches</h2><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">Examples at <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">/examples/example_draw_bezier_patch.cpp</div></strong> </p></blockquote><p class=\"css-0\">Bezier patches of 2nd and 3rd degree, Quadratic and Cubic orders are supported as well</p><img src=\"/images/canvas_bezier_patch.png\" style=\"height:250px;margin:auto\"/><h2 class=\"css-0\">Lines (Wu lines)</h2><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">Examples at <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">/examples/example_3d_simple_pipeline.cpp</div></strong> </p></blockquote><style data-emotion=\"css naa80m\">.css-naa80m{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:gray.800;background-color:gray.200;padding:2;padding-left:2px;border-radius:md;border-left-width:10px;border-left-color:purple.500;}</style><blockquote class=\"css-naa80m\"><p class=\"css-0\">Examples at <style data-emotion=\"css 10ircq3\">.css-10ircq3{font-weight:semibold;}</style><strong class=\"css-10ircq3\"><style data-emotion=\"css qskmz3\">.css-qskmz3{color:purple.600;display:inline;}</style><div class=\"css-qskmz3\">/examples/example_geometry_bezier_curve_divider.cpp</div></strong> </p></blockquote><p class=\"css-0\">Wu lines algorithm is supported, it is a fast DDA algorithm, supports anti-aliasing\nbut is not very accurate.</p><img src=\"/images/canvas_wu_lines.png\" style=\"height:250px;margin:auto\"/>","scope":{}},"frontMatter":{},"document":{"name":"docs","groups":[{"title":"Getting Started","items":[{"title":"Setup","route":"getting-started/setup","path":"content/docs/setup.mdx"},{"title":"Features","route":"getting-started/features","path":"content/docs/features.mdx"}]},{"title":"Concepts","items":[{"title":"Numbers","route":"concepts/numbers","path":"content/docs/numbers.mdx"},{"title":"Math","route":"concepts/math","path":"content/docs/math.mdx"},{"title":"RGBA","route":"concepts/rgba","path":"content/docs/rgba.mdx"},{"title":"Pixel Coders","route":"concepts/pixel-coders","path":"content/docs/pixel-coders.mdx"},{"title":"Samplers","route":"concepts/samplers","path":"content/docs/samplers.mdx"},{"title":"Composition","route":"concepts/composition","path":"content/docs/composition.mdx"},{"title":"Bitmaps","route":"concepts/bitmaps","path":"content/docs/bitmaps.mdx"},{"title":"3D Shaders","route":"concepts/3d","path":"content/docs/3d.mdx"},{"title":"Canvas","route":"concepts/canvas","path":"content/docs/canvas.mdx"}]},{"title":"Drawing","items":[{"title":"Rectangles","route":"drawing/rectangles","path":"content/docs/rectangles.mdx"},{"title":"Rounded Shapes","route":"drawing/rounded","path":"content/docs/rounded.mdx"},{"title":"Quadrilaterals","route":"drawing/quadrilaterals","path":"content/docs/quadrilaterals.mdx"},{"title":"Triangle","route":"drawing/triangle","path":"content/docs/triangle.mdx"},{"title":"Triangle Batches","route":"drawing/triangle-batches","path":"content/docs/triangle-batches.mdx"},{"title":"Polygons","route":"drawing/polygons","path":"content/docs/polygons.mdx"},{"title":"Masks","route":"drawing/masks","path":"content/docs/masks.mdx"},{"title":"Path Fills","route":"drawing/path-fills","path":"content/docs/path-fills.mdx"},{"title":"Path Strokes","route":"drawing/path-stroke","path":"content/docs/path-stroke.mdx"},{"title":"Bezier Patches","route":"drawing/bezier-patches","path":"content/docs/patches.mdx"},{"title":"Lines","route":"drawing/lines","path":"content/docs/lines.mdx"},{"title":"Text","route":"drawing/text","path":"content/docs/text.mdx"},{"title":"Gradients","route":"drawing/gradients","path":"content/docs/gradients.mdx"},{"title":"More Samplers","route":"drawing/more-samplers","path":"content/docs/more-samplers.mdx"},{"title":"3D","route":"drawing/3d","path":"content/docs/draw-3d.mdx"}]},{"title":"Geometry","items":[{"title":"Intro","route":"geometry/intro","path":"content/docs/wip.mdx"}]}],"__map":{"getting-started/setup":"content/docs/setup.mdx","getting-started/features":"content/docs/features.mdx","concepts/numbers":"content/docs/numbers.mdx","concepts/math":"content/docs/math.mdx","concepts/rgba":"content/docs/rgba.mdx","concepts/pixel-coders":"content/docs/pixel-coders.mdx","concepts/samplers":"content/docs/samplers.mdx","concepts/composition":"content/docs/composition.mdx","concepts/bitmaps":"content/docs/bitmaps.mdx","concepts/3d":"content/docs/3d.mdx","concepts/canvas":"content/docs/canvas.mdx","drawing/rectangles":"content/docs/rectangles.mdx","drawing/rounded":"content/docs/rounded.mdx","drawing/quadrilaterals":"content/docs/quadrilaterals.mdx","drawing/triangle":"content/docs/triangle.mdx","drawing/triangle-batches":"content/docs/triangle-batches.mdx","drawing/polygons":"content/docs/polygons.mdx","drawing/masks":"content/docs/masks.mdx","drawing/path-fills":"content/docs/path-fills.mdx","drawing/path-stroke":"content/docs/path-stroke.mdx","drawing/bezier-patches":"content/docs/patches.mdx","drawing/lines":"content/docs/lines.mdx","drawing/text":"content/docs/text.mdx","drawing/gradients":"content/docs/gradients.mdx","drawing/more-samplers":"content/docs/more-samplers.mdx","drawing/3d":"content/docs/draw-3d.mdx","geometry/intro":"content/docs/wip.mdx"}}}},"__N_SSG":true}